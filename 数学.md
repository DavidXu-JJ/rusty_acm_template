[TOC]

<div STYLE="page-break-after: always;"></div>

# 数论

## GCD
```c++
int gcd(int a,int b)
{
    if(b==0)return a;
    return gcd(b,a%b);
}
int lcm(int a,int b)
{
    return a/gcd(a,b)*b;
}
```
## O(1)龟速乘

> 防止乘法爆long long，大于1e10的乘法出现时使用

```c++
ll mul(ll a, ll b, ll m) {
	return (a * b - ll((long double)a * b / m) * m + m) % m;
}
```

## 朴素检验素数

```c++
// 求平方根，注意sqrt()的参数为 double 类型，这里要强制转换m的类型 
k=(int)sqrt( (double)m );
for(i=2;i<=k;i++)
  if(m%i==0)
    break;
```

## Miller-Robin素数检测

> O(k*log<sup>3</sup>n)，k为检测次数

```c++
ll mul(ll a, ll b, ll m) {
	return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll power(ll v, ll p, ll m) {
	ll r = 1;
	while (p) {
		if (p & 1) r=mul(r,v,m);
		v=mul(v,v,m);
		p >>= 1;
	}
	return r;
}
bool witness(ll a, ll p) {
	int k = 0;
	ll q = p - 1;
	while ((q & 1) == 0) ++k, q >>= 1;
	ll v = power(a, q, p);
	if (v == 1 || v == p - 1) return false; // probably prime number
	
	while (k-- != 0) {
		v = mul(v,v,p);
		if (v == p - 1) return false;
	}
	return true; // composite number
}

mt19937 rnd(233);
bool miller_rabin(ll p) {
	if (p == 1) return false;
	if (p == 2) return true;
	if (p % 2 == 0) return false;
	for (int i = 0; i != 50; ++i) {
		ll a = rnd() % (p - 1) + 1;
		if (witness(a, p)) return false;
	}
	return true;
}
```

## Pollard_Rho分解质因数

> O(n^1/4)

```c++
ll mul(ll a, ll b, ll m) {
	return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll power(ll v, ll p, ll m) {
	ll r = 1;
	while (p) {
		if (p & 1) r=mul(r,v,m);
		v=mul(v,v,m);
		p >>= 1;
	}
	return r;
}
bool witness(ll a, ll p) {
	int k = 0;
	ll q = p - 1;
	while ((q & 1) == 0) ++k, q >>= 1;
	ll v = power(a, q, p);
	if (v == 1 || v == p - 1) return false; // probably prime number
	
	while (k-- != 0) {
		v = mul(v,v,p);
		if (v == p - 1) return false;
	}
	return true; // composite number
}

mt19937 rnd(233);
bool miller_rabin(ll p) {
	if (p == 1) return false;
	if (p == 2) return true;
	if (p % 2 == 0) return false;
	for (int i = 0; i != 50; ++i) {
		ll a = rnd() % (p - 1) + 1;
		if (witness(a, p)) return false;
	}
	return true;
}

ll pollard_rho(ll n, int a) {//依概率分解出n的一个因子
	
	ll x = 2, y = 2, d = 1, k = 0, i = 1;
	while(d == 1) {
		++k;
		x = mul(x, x, n) + a;
		d = gcd(x >= y ? x - y : y - x, n);
		if(k == i) { y = x; i <<= 1;}
	}
	if(d == n) return pollard_rho(n, a + 1);
	return d;
}

vi fac;
void decomp(ll n) {
	if(miller_rabin(n)) {
		fac.push_back(n);
		return;
	}
	ll d=pollard_rho(n,233);
	if(n!=d) decomp(n/d);
	decomp(d);
}
void getfac(ll n) {
	fac.clear();
	if(n>1) decomp(n);
}
```

> 超级高级版本

```c++
template<typename T,typename UT> class montctx_t{ private:
	typedef T val_t;
	typedef UT mval_t;
	static const int tlen=sizeof(val_t)*8;
public:
	val_t mdn,mdn2,p2,r;
	montctx_t(val_t x=998244353):mdn(x),mdn2(x<<1),p2(-mval_t(mdn)%mdn),r(1){
		for(int i=1;i<tlen;i<<=1)r*=2+r*mdn; }
		inline val_t redc(mval_t x)const{return (x+(val_t(x)*r)*mval_t(mdn))>>tlen;} inline val_t redu(val_t x)const{return x>=mdn2?x-mdn2:x;}
		inline val_t reds(val_t x)const{return x>=mdn?x-mdn:x;}
	};
	typedef montctx_t<uint64_t,unsigned __int128> montctx64_t;
	template<typename T,typename UT> class mont_t{ private:
		typedef T val_t;
		typedef UT mval_t;
		static montctx_t<T,UT> ctx; val_t v;
	public:
		static montctx_t<T,UT> getctx(){return ctx;}
		static void setctx(const montctx_t<T,UT>&x){ctx=x;}
		explicit operator val_t()const{return ctx.reds(ctx.redc(v));}
		mont_t(val_t x){v=ctx.redc(x*(mval_t)ctx.p2);}
		mont_t(){}
		mont_t(const mont_t&a):v(a.v){}
		mont_t&operator+=(const mont_t&a){v=ctx.redu(v+a.v);return*this;} mont_t&operator-=(const mont_t&a){v=ctx.redu(v-a.v+ctx.mdn2);return*this;} mont_t&operator*=(const mont_t&a){v=ctx.redc(v*(mval_t)a.v);return*this;} mont_t&operator=(const mont_t&a){v=a.v;return*this;}
		mont_t operator+(const mont_t&a)const{return mont_t(*this)+=a;}
		mont_t operator-(const mont_t&a)const{return mont_t(*this)-=a;}
		mont_t operator*(const mont_t&a)const{return mont_t(*this)*=a;}
		mont_t operator-()const{mont_t r;r.v=(v?ctx.mdn2-v:0);return r;}
		bool operator==(const mont_t&a)const{return ctx.reds(v)==ctx.reds(a.v);}
		
		bool operator!=(const mont_t&a)const{return !(*this==a);}
		friend std::istream&operator>>(std::istream&s,mont_t&v){val_t tmp;s>>tmp;v=mont_t(tmp);return s;}
		friend std::ostream&operator<<(std::ostream&s,const mont_t&v){return s<<val_t(v);}
	};
	typedef mont_t<uint64_t,unsigned __int128> mont62_t;
	template<> montctx64_t mont62_t::ctx=montctx64_t(998244353); typedef unsigned __int128 uint128_t;
	mont62_t qpwm(mont62_t bse,uint64_t ex){ mont62_t ret(1);
		for(;ex;ex>>=1){
			if(ex&1)ret*=bse;
			bse*=bse; }
		return ret; }
	uint64_t qpw(uint64_t bse,uint64_t ex){ uint64_t ret=1;
		for(;ex;ex>>=1){
			if(ex&1)ret=ret*bse;
			bse=bse*bse; }
		return ret; }
	uint64_t gcd(uint64_t a,uint64_t b){ int s=0;
		while(b){
			if(a<b)swap(a,b);
			else if((~a&1)&&(~b&1))a>>=1,b>>=1,s++; else if(~a&1)a>>=1;
			else if(~b&1)b>>=1;
			else a-=b;
		}
		return a<<s; }
	bool miller_u64(uint64_t x){
		if(x==2)return 1;
		if(x<2||~x&1)return 0;
		uint64_t y=x-1;int cnt=0;
		for(;~y&1;y>>=1)cnt++;
		const static uint32_t bse[]={2,325,9375,28178,450775,9780504,1795265022};
		
		mont62_t::setctx(montctx64_t(x)); for(uint32_t g:bse){
			mont62_t u=qpwm(g,y); if(u==1||u==0)continue; bool ok=0;
			for(int j=0;j<cnt;j++){
				if(u==x-1){ok=1;break;}
				u*=u; }
			if(!ok)return 0; }
			return 1; }
		const int maxp=5,facp=5; const int ext=14;
		int prm[maxp]; vector<int> qr[maxp]; double lg[maxp]; montctx64_t ctx[maxp];
		void init(){
			for(int i=2,t=0;t<maxp;i++)if(miller_u64(i)){
				prm[t]=i; qr[t].resize(prm[t],-1); for(int i=0;i<prm[t];i++){
					int nz=i*i%prm[t];
					qr[t][nz]=i; }
				ctx[t]=montctx64_t(i); lg[t]=log(i);
				t++;
			} }
		mt19937 rng(chrono::steady_clock().now().time_since_epoch().count()); template<typename t> t rndi(t l,t r){return uniform_int_distribution<t>(l,r)(rng);}
		vector<uint64_t> factor(uint64_t x);
		const int dif=512;
		vector<uint64_t> pollard_rho(uint64_t x){ mont62_t::setctx(montctx64_t(x)); while(1){
			
			mont62_t c=rndi<uint64_t>(0,x-1),a=rndi<uint64_t>(0,x-1); mont62_t b=a;
			for(int cd=1;;cd=min(dif,cd<<1)){
				mont62_t prod=1; bool typ=0;
				for(int i=0;i<cd;i++){
					a=a*a+c; b=b*b+c;b=b*b+c; mont62_t cur=a-b; if(cur==0){
						typ=1;
						break; }
					prod*=cur; }
				uint64_t g=gcd((uint64_t)prod,x); if(g!=1){
					vector<uint64_t> f1=factor(x/g),f2=factor(g); for(uint64_t u:f2)f1.push_back(u);
					return f1;
				}
				if(typ)break; }
			} }
			/*
			struct row{
			bitset<maxp> a;
			bitset<maxp+ext> b; }bs[maxp];
			struct rf{
			int pw[maxp]; mont62_t x;
			}org[maxp+ext];
			const int stx=50;
			double val[maxp*stx];
			int pid[maxp];
			vector<uint64_t> quadratic_sieve(uint64_t x){
			int b=lroundl(expl(sqrtl(logl(x)*logl(logl(x)))/2)*5+1); uint64_t h=sqrtl(x)+0.5;
			int t=0;
			while(prm[t]<=b)t++;
			int nt=0;
			for(int i=0;i<t;i++){
			
			if(qr[i][x%prm[i]]!=-1){ pid[nt++]=i;
			} }
			t=nt;
			int cnt=0;
			int step=t*stx;
			int err=0;
			int thres=sqrt(sqrt(x))*10; for(int s=0;;s+=step){
			for(int i=0;i<step;i++)val[i]=0; for(int i=0;i<t;i++){
			int v[2];
			int z=prm[pid[i]]; v[0]=qr[pid[i]][x%z]; v[1]=(z-v[0])%z; for(int t=0;t<2;t++){
			int u=(z-(h+s)%z+v[t])%z;
			for(int j=u;j<step;j+=z)val[j]+=lg[i]; }
			}
			double curlg=log((h+s)*(h+s)-x); for(int i=0;i<step;i++){
			if(val[i]<curlg-7)continue;
			uint64_t cur=(h+s+i)*(h+s+i)-x,y=cur; for(int j=0;j<t;j++){
			org[cnt].pw[j]=0;
			int z=prm[pid[j]]; while(z==2?~y&1:ctx[pid[j]].reds(ctx[pid[j]].redc(y))==0){
			y/=z;
			org[cnt].pw[j]++; }
			} org[cnt].x=h+s+i; if(y==1){
			cnt++; }else err++; if(cnt==t+ext){
			cerr<<s+i<<' '<<cnt<<endl;
			break; }
			}
			if(s>thres)return pollard_rho(x); if(cnt==t+ext)break;
			} mont62_t::setctx(montctx64_t(x));
			
			for(int i=0;i<t;i++)bs[i].a.reset(); for(int i=0;i<t+ext;i++){
			row s;
			for(int j=0;j<t;j++)s.a[j]=org[i].pw[j]&1; s.b[i]=1;
			for(int j=0;j<t;j++){
			if(s.a[j]){ if(bs[j].a[j]){
			s.a^=bs[j].a;s.b^=bs[j].b; }else{
			bs[j]=s;break; }
			} }
			if(s.a.none()){
			mont62_t px=1,py=1;
			for(int j=0;j<t+ext;j++)if(s.b[j]){
			px*=org[j].x; }
			for(int j=0;j<t;j++){ int pw=0;
			for(int k=0;k<t+ext;k++)if(s.b[k]){ pw+=org[k].pw[j];
			}
			py*=qpwm(prm[pid[j]],pw/2); }
			uint64_t cx=uint64_t(px),cy=uint64_t(py); for(int t=0;t<2;t++){
			uint64_t dif=cx+cy; if(t){
			if(cx>cy)dif=cx-cy;
			else dif=cy-cx; }
			uint64_t g=gcd(dif,x); if(g!=1&&g!=x){
			vector<uint64_t> fx=factor(g),fy=factor(x/g); for(uint64_t u:fy)fx.push_back(u);
			return fx;
			} }
			} }
			return pollard_rho(x); }
			const uint64_t pollard_limit=1e15; */
			
			vector<uint64_t> factor(uint64_t x){ if(x==1)return {}; if(miller_u64(x))return {x}; if(~x&1){
				int cnt=0;for(;~x&1;x>>=1)cnt++; vector<uint64_t> res=factor(x); while(cnt--)res.push_back(2); return res;
			}
				for(int i=1;i<facp;i++)if(ctx[i].reds(ctx[i].redc(x))==0){
					vector<uint64_t> c=factor(x/prm[i]); c.push_back(prm[i]);
					return c;
				}
				return pollard_rho(x);
				/*
				long double z=logl(x);
				uint64_t cur=4;
				for(int i=2;cur<=x;i++,cur<<=1){
				uint64_t f=llroundl(expl(z/i));
				for(uint64_t h=max((uint64_t)2,f-1);h<=f+1;h++){
				if(qpw(h,i)==x){
				vector<uint64_t> z=factor(h);
				vector<uint64_t> z1=z;
				for(int j=1;j<i;j++)for(uint64_t c:z)z1.push_back(c); return z1;
				} }
				}
				if(x<pollard_limit)return pollard_rho(x); return quadratic_sieve(x);*/
			}

```

## 素数计数函数/素数密度

小于或等于素数的个数
$$
\pi(x)～\cfrac{x}{lnx}
$$


## 埃氏筛

```c++
#include<iostream>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
const int SIZE=100
bool vis[SIZE+1];		//1不是素数
void aisi_prime(ll n)
{
	memset(vis,0,sizeof(vis));
	vis[1]=1;
	for(ll i=2;i*i<=n;i++)
	{
		if(!vis[i])
		{
			for(ll j=i*i;j<=n;j+=i)
			{
				vis[j]=1;
			}
		}
	}
}
```
## 欧拉筛
```c++
const int maxn=100000001;
int prime[maxn];      //就是个素数表
bool sf[maxn];        //判断这个数是不是素数，sf[i]中的i是从1到maxn的数
void sushu(){         //核心 欧拉筛代码
    int num=0;        //num 用来记筛到第几个质数
    memset(sf,true,sizeof(sf));
    for(int i=2;i<maxn;i++){          //外层枚举1~maxn
        if(sf[i]) prime[++num]=i;      //如果是质数就加入素数表
        for(int j=1;j<=num && i*prime[j]<maxn;j++){       //内层枚举num以内的质数
         //   if(i*prime[j]>=maxn) break; //筛完结束
            sf[i*prime[j]]=false;      //筛掉...
            if(i%prime[j]==0) break;   //避免重复筛
        }
    }
    sf[1]=false;
    sf[0]=false;  //1 0 特判 
}
```
## 因数个数筛

```c++
const int maxn=5e4+10;
int prime[maxn];
bool sf[maxn];	//0为质数，1为合数
int d[maxn]; 	//d为因数个数
int t[maxn];	//t为最小质因数出现次数
void init(){
	int num=0;
	d[1]=1;
	sf[0]=sf[1]=1;
	for(int i=2;i<maxn;++i){
		if(!sf[i]) prime[++num]=i,t[i]=1,d[i]=2;
		for(int j=1;j<=num && i*prime[j]<maxn;++j){
			sf[i*prime[j]]=1;
			if(i%prime[j]==0){
				d[i*prime[j]]=d[i]/(t[i]+1)*(t[i]+2);	
				t[i*prime[j]]=t[i]+1;
				break;
			}
			d[i*prime[j]]=d[i]<<1,t[i*prime[j]]=1;
		}
	}
}
```



## 质因数分解

p[20]存底数，q[20]存指数

> O(根号n)

```c++
int p[20],q[20],o;
void getfactor(int n){
  o=0;
  for(int i=2;i*i<=n;i++)
  {
    if(n%i==0)
    {
      int c=0;
      while(n%i==0) n/=i,c++;
      p[++o]=i,q[o]=c;	//从1开始存,o位置有元素
    }
  }
  if(n>1) p[++o]=n,q[o]=1;
}
```

> O(根号(n/logn))（需要初始化素数）

```c++
int p[20],q[20],o;
void getfactor(int n){
  o=0;
  for(int i=1;i<=cnt;i++){
    if(prime[i]*prime[i]>n)break;
    if(n%prime[i]==0){
      int c=0;
      while(n%prime[i]==0) n/=prime[i],c++;
      p[++o]=prime[i],q[o]=c;	//从1开始存,o位置有元素
    }
  }
  if(n>1) p[++o]=n,q[o]=1;
}
```

> O(n^1/4+logn)

```c++
ll gcd(ll a,ll b)
{
	if(b==0)	return a;
	return gcd(b,a%b);
}
ll mul(ll a, ll b, ll m)
{
	return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll power(ll v, ll p, ll m)
{
	ll r = 1;
	while (p)
		{
			if (p & 1) r=mul(r,v,m);
			v=mul(v,v,m);
			p >>= 1;
		}
	return r;
}
bool witness(ll a, ll p)
{
	int k = 0;
	ll q = p - 1;
	while ((q & 1) == 0) ++k, q >>= 1;
	ll v = power(a, q, p);
	if (v == 1 || v == p - 1) return false; // probably prime number
	while (k-- != 0)
		{
			v = mul(v,v,p);
			if (v == p - 1) return false;
		}
	return true; // composite number
}
bool miller_rabin(ll p)
{
	if (p == 1) return false;
	if (p == 2) return true;
	if (p % 2 == 0) return false;
	for (int i = 0; i != 50; ++i)
		{
			ll a = rand() % (p - 1) + 1;
			if (witness(a, p)) return false;
		}
	return true;
}
ll pollard_rho(ll n, int a)//依概率分解出n的一个因子
{
	ll x = 2, y = 2, d = 1, k = 0, i = 1;
	while(d == 1)
		{
			++k;
			x = mul(x, x, n) + a;
			d = gcd(x >= y ? x - y : y - x, n);
			if(k == i) { y = x; i <<= 1;}
		}
	if(d == n) return pollard_rho(n, a + 1);
	return d;
}

vector<int> fac;
void decomp(ll n)
{
	if(miller_rabin(n))
		{
			fac.push_back(n);
			return;
		}
	ll d=pollard_rho(n,233);
	if(n!=d) decomp(n/d);
	decomp(d);
}
void getfac(ll n)
{
	fac.clear();
	if(n>1) decomp(n);
}
ll eular(ll n)
{
	ll res=1ll;
	getfac(n);
	sort(fac.begin(),fac.end());
	fac.erase(unique(fac.begin(), fac.end()),fac.end());
	for(int i:fac)
	{
		n/=i;
		res*=(i-1);
		while(n%i==0)	n/=i,res*=i;
	}
	return res;
}
```



## 区间筛

```c++
#include<iostream>
#include<algorithm>

using namespace std;
#define ll long long

const int maxn =2e8+10;
const int maxs =3e5+10;

bool is_prime[maxn];
bool is_prime_small[maxs];


void segment_sieve(ll a,ll b)
{
    for(int i=0; i*i < b; i++)is_prime_small[i]=true;
    for(int i=0; i<b-a; i++)is_prime[i]=true;
    for(int i=2; i * i<b; i++)
    {
        if(is_prime_small[i])
        {
            for(int j=2*i;j * j < b; j += i)
            {
                is_prime_small[j]=false;
            }
            int top=max(2ll, (a+i-1)/i) ;
            for(int j=top*i ; j<b; j+=i)         
                {
                is_prime[j - a] =false;
            }
        }
    }
}

int main()
{
    ll l,r;
    cin>>l>>r;
    segment_sieve(l, l+2*r);
    ll cnt=0;
    for(int i=0;i<2*r;i++)
    {
        if(is_prime[i])
            cnt++;
    }
    if(cnt>r)
        cout<<"Yes";
    else cout<<"No";
    return 0;
}
```
## 取模乘法(类似快速幂)
>O(logb)

```c++
ll mod_Multi(ll a,ll b ,ll mod) 
{
	a%=mod;b%=mod;
	ll ans=0;
	while(b)
	{
		(ans+=(b%2)*a)%=mod;
		a<<=1;
		a%=mod;
		b>>=1;
	}
	return ans;
}
```

>O(1)

```c++
ll mod_Multi(ll a,ll b ,ll p) 
{
	a%=p;b%=p;
	ll c=(long double)(a)*b/p;
	ll ans=a*b-c*p;
	if(ans<0) ans+=p;
	else if(ans>=p) ans-=p;
	return ans;
}
```
## 快速幂取模
```c++
ll qpowMod(ll n,ll m)
{
    ll res=1;
    ll  multi=n;
    while(m!=0)
    {
        if((m&1)==1)
        {
            res=(res*multi)%mod;
        }
        multi=(multi*multi)%mod;
        m/=2;
        //m>>=1;
    }
    return res;
}
```
## 欧拉定理+阶和原根

若
$$
gcd(a,m)=1，则a^{\phi(m)}\equiv 1(mod\ m)\\
满足a^{n}\equiv1(mod\ m)的最小正整数称为a模m的阶，记作\delta_{m}(a)
$$
可推出费马小定理。

> 阶的性质

1. $a,a^{2},...,a^{\delta_{m}(a)}$模m两两不同余。

2. 若$a^{n}\equiv1(mod\ m)$，则$\delta_{m}(a)|n$。

   若$a^{p}\equiv a^{q}(mod\ m)$，则有$p\equiv q(mod\ \delta_{m}(a))$。

3. $m\in N^{*}$，$gcd(a,m)=gcd(b,m)=1$，则$\delta_{m}(ab)=\delta_{m}(a)\delta_{m}(b)$的充分必要条件是$gcd(\delta_{m}(a),\delta_{m}(b))=1$。

4. $k\in N,m\in N^{*},a\in Z,gcd(a,m)=1$，则

$$
\delta_{m}(a^{k})=\cfrac{\delta_{m}(a)}{gcd(\delta_{m}(a),k)}
$$

## 原根

> 原根

$m\in N^{*},a\in Z,若\ gcd(a,m)=1,且\ \delta_{m}(a)=\phi(m),则称a为模m的原根.$

> 原根判定定理

设$m\geq 3,gcd(a,m)=1$，则a是模m的原根的充要条件是，对于$\phi(m)$的每个素因数p，都有$a^{\cfrac{\phi(m)}{p}}\not\equiv1(mod\ m)$。

> 原根个数

若一个数m有原根，则它原根的个数为$\phi(\phi(m))$。

> 原根存在定理

一个数m存在原根当且仅当$m=2,4,p^{\alpha},2p^{\alpha}$，其中p为奇素数，$\alpha\in N^{*}$。

> 最小原根的数量级

最小原根是不多于$m^{0.25}$级别的，可以暴力搜。

> 求原根

<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/求原根.png" alt="求原根" style="zoom:50%;" />

> 与单位根的关系

p的原根是满足$g^{0}\%p,g^{1}\%p,g^{2}\%p…g^{p−2}\%p$恰好等于\[1,p−1\]中的所有数的最小的g。

我们称$g_{n}$为n的原根，那么我们也得到了类似于$w_{n}^{k}$一长串的$g_{n}^{0},g_{n}^{1},g_{n}^{2},…,g_{n}^{n−2}$而且他们模意义下和\[1,p−1\]中的所有数一一对应。

性质1:
$$
g_{n}^{k}=g_{2n}^{2k}
$$
性质2:
$$
g_{n}^{\cfrac{n}{2}}=-1,g_{n}^{0}=g_{n}^{n}=1
$$

性质3:
$$
g_{n}^{k+\cfrac{n}{2}}=-g_{n}^{k}
$$


```C++
const int N=1e6+7;
int rt[N],cans,ans[N],factor[N],c2=0;
void getphi() {
    getprime and phi; //筛一下
    //2,4,p^e,2p^e,存在性判定
    rt[2]=rt[4]=1;
    for(int i=1;i<c1;++i) {
        for(int j=1;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
        for(int j=2;(1ll*j*prime[i])<maxn;j*=prime[i]) rt[j*prime[i]]=1;
    }
}
int quick(int a,int b,int p)
void getfac(int p) {
    c2=0;
    for(int i=2;i*i<=p;++i)
        if(p%i==0) {
            factor[c2++]=i;
            while(p%i==0) p/=i;
        }
    if(p>1) factor[c2++]=p;
}
int find_smallest_primitive_root(int p) {//素数的话直接改p-1
    getfac(phi[p]);
    for(int i=1;i<=p;++i) {
        bool flag=true;
        if (quick(i,phi[p],p)!=1) continue;
        for(int j=0;j<c2;++j) {
            if (quick(i,phi[p]/factor[j],p)==1) {
                flag=false;
                break;
            }
        }
        if(flag) return i;
    }
    assert(0); return -1;
}
void getrt(int p,int x) {//x是最小原根,找所有原根
    cans=0;
    int cur=1;
    for(int i=1;i<=phi[p];++i) {
        cur=(1ll*cur*x)%p;
        if(__gcd(i,phi[p])==1) ans[cans++]=cur;
    }
}
```

## 拓展欧拉定理

![拓展欧拉定理](/Users/davidxu/Desktop/算法笔记md/math_pic/拓展欧拉定理.png)
$$
a^{b^{c}}则可以递归降幂
$$

```c++
ll mul(ll a, ll b, ll m) {
	return (a * b - ll((long double)a * b / m) * m + m) % m;
}
int gcd(int a,int b){
	return b==0?a:gcd(b,a%b);
}
ll eular(ll n){
	ll ret=1,i;
	for (i=2;i*i<=n;i++)
		if (n%i==0){
			n/=i,ret*=i-1;
			while (n%i==0)
				n/=i,ret*=i;
		}
	if (n>1)
		ret*=n-1;
	return ret;
}
int qpow(int a,int b,const int mo){//模数大于1e9需要龟速乘
	int res=1;
	while(b){
		if(b&1) res=(res*a)%mo;		//res=mul(res,a,mo);
		a=(a*a)%mo;		//a=mul(a,a,mo);
		b>>=1;
	}
	return res;
}
int str_mod(string s,const int mo){
	int res=0;
	for(int i=0;i<s.size();++i){
		res=res*10+s[i]-'0';
		res%=mo;
	}
	return res;
}
//a^b mod m
int ex_eular(string a,string b,const int mo){
	int low=str_mod(a,mo);
	int high=0;
	bool flag=false;
	int phi=eular(mo);
	for(int i=0;i<b.size();++i){
		high=high*10+b[i]-'0';
		if(high>=phi){
			flag=true;
			high%=phi;
		}
	}
	if(flag) high+=phi;
	return qpow(low,high,mo);
}
```

## 求逆元

1. 使用费马小定理，要求模数p为素数，逆元为a的p-2次方。

2. 使用欧拉定理，a与p互素时，由于
   $$
   a^{\phi(p)}\equiv1(mod\ p)
   $$
   所以逆元为
   $$
   inv(a)=a^{\phi(p)-1}
   $$
   
3. 使用扩展欧几里得定理，不要求模数p为素数。  

```c++
ll inv(ll a, ll p) //求a关于p的逆元
{
    ll x, y;	//x,y最开始不为0
    ll d = exgcd(a, p, x, y);
    if (d != 1)
        return -1;	//不存在逆元
    return (x % p + p) % p;
}
```

4. 基于

$$
inv(a)=(p- \lfloor p/a \rfloor)*inv(p\%a)\%p
$$


O(n)时间复杂度下求出逆元表。

```c++
void init()
{
    inv[1] = 1;
    for (int i = 2; i < maxn; i++)
        inv[i] = (mod - mod / i) * 1LL * inv[mod % i] % mod;
}
```

> O(n)生成阶乘逆元

```c++
 fact[0] = 1;
  for (int i = 1; i <= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;
  exgcd(fact[n], mod, ifact[n], ifact[0]),
      ifact[n] = (ifact[n] % mod + mod) % mod;
  for (int i = n - 1; i >= 0; --i) ifact[i] = (ll)ifact[i + 1] * (i + 1) % mod;
```

## 拓展欧几里得

```c++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0){x=1;y=0;return a;}
    ll gcd=exgcd(b,a%b,x,y);
    ll tp=x;
    x=y; y=tp-a/b*y;
    return gcd;
}
//都行
int exgcd(int a, int b, int &x, int &y)
 {
    int d = a;
    if (b) d = exgcd(b, a % b, y, x), y -= x * (a / b);
    else x = 1, y = 0;
      return d;
 }
```
## 中国剩余定理（CRT）
```c++
#include<iostream>
#include<cmath>
#include<iomanip>
#include<vector>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int maxn=10010;
ll n;
inline int rd(){
    int io=0;char in=getchar();
    while(in<'0'||in>'9')in=getchar();
    while(in>='0'&&in<='9')io=(io<<3)+(io<<1)+(in^'0'),in=getchar();
    return io;
}
void exgcd(ll a,ll b,ll &x,ll &y){
    if(b==0){x=1;y=0;return ;}
    exgcd(b,a%b,x,y);
    int z=x;x=y,y=z-y*(a/b);
}
ll CRT(ll * number,ll *mod,ll len)	//取模mod，未知数与数组number同余，len为方程个数
{
    ll Mi[len+10];
    ll ans=0;
    ll mul=1;
    for(int i=0;i<len;i++)
        {
            mul*=mod[i];
            number[i]%=mod[i];
        }
    for(int i=0;i<len;i++)
    {
        Mi[i]=mul/mod[i];
        ll x=0,y=0;
        exgcd(Mi[i],mod[i],x,y);
        ans+=number[i]*Mi[i]*(x<0?x+mod[i]:x);
    }
    return ans%mul;
}
int main(){
    while(cin>>n)
    {
        ll number[maxn],mod[maxn];
        for(int i=0;i<n;i++)
        {
            cin>>number[i]>>mod[i];
        }
        cout<<CRT(number, mod, n)<<endl;
    }
}


```
## 拓展中国剩余定理（EXCRT）

* 逐项合并，支持不互质，无解返回-1
* 前置exgcd
* 使用m数组的lcm值来作为步长，求其他解
* O(nlog)

```c++
ll mul(ll a, ll b, ll m) {
	return (a * b - ll((long double)a * b / m) * m + m) % m;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(b==0){x=1;y=0;return a;}
	ll gcd=exgcd(b,a%b,x,y);
	ll tp=x;
	x=y; y=tp-a/b*y;
	return gcd;
}
ll CRT(ll *m, ll *r, ll n)	//x mod m = r	,	从0位置开始存	,不包括位置n
{
	if (!n)
		return 0;
	ll M = m[0], R = r[0], x, y, d;
	for (int i = 1; i < n; i++)
		{
			d = exgcd(M, m[i], x, y);
			if ((r[i] - R) % d)
				return -1;
			x = (r[i] - R) / d * x % (m[i] / d);
			//x = mul ( (r[i]-R) /d , x , m[i]/d );		//注意数据范围，有1e10以上的数字相乘用龟速乘
			R += x * M;
			M = M / d * m[i];
			R %= M;
		}
	return R >= 0 ? R : R + M;
}
```
## 高精度乘法

```c++
ll mut(ll a,ll b,ll mod)//高精度求乘法
{
    ll an=0;
    while(b){if(b&1)an=(an+a)%mod;b>>=1,a=(a<<1)%mod;}
    return an;
}
```


## 大数阶乘取模O(sqrt(n)*logn)

```c++
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;const int N=262144+10;typedef unsigned long long ll;
const int P=65536;const int SF=16;const int msk=65535;ll mod;ll PP;
typedef long double ld;const ld pi=acos(-1.0);
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
struct cmp
{
    ld r;ld v;
    friend cmp operator +(cmp a,cmp b){return (cmp){a.r+b.r,a.v+b.v};}
    friend cmp operator -(cmp a,cmp b){return (cmp){a.r-b.r,a.v-b.v};}
    friend cmp operator *(cmp a,cmp b){return (cmp){a.r*b.r-a.v*b.v,a.r*b.v+a.v*b.r};}
    void operator /=(const int& len){r/=len;v/=len;}
}rt[2][22][N],tr[N],tr1[N],tr2[N],tr3[N],tr4[N],tr5[N],tr6[N];
int rv[22][N];ll m13[N],m14[N],m23[N],m24[N];
inline void pre()
{
    for(int d=1;d<=18;d++)
        for(int i=1;i<(1<<d);i++)rv[d][i]=(rv[d][i>>1]>>1)|((i&1)<<(d-1));
    for(int d=1,t=1;d<=18;d++,t<<=1)
        for(int i=0;i<(1<<d);i++)rt[0][d][i]=(cmp){cos(pi*i/t),sin(pi*i/t)};
    for(int d=1,t=1;d<=18;d++,t<<=1)
        for(int i=0;i<(1<<d);i++)rt[1][d][i]=(cmp){cos(pi*i/t),-sin(pi*i/t)};
}inline void fft(cmp* a,int len,int d,int o)
{
    for(int i=1;i<len;i++)if(i<rv[d][i])swap(a[i],a[rv[d][i]]);cmp* w;int i;
    for(int k=1,j=1;k<len;k<<=1,j++)
        for(int s=0;s<len;s+=(k<<1))
            for(i=s,w=rt[o][j];i<s+k;i++,++w)
                {cmp a1=a[i+k]*(*w);a[i+k]=a[i]-a1;a[i]=a[i]+a1;}
    if(o)for(int i=0;i<len;i++)a[i]/=len;
}inline void dbdft(ll* a,int len,int d,cmp* op1,cmp* op2)
{
    for(int i=0;i<len;i++)tr[i]=(cmp){(ld)(a[i]>>SF),(ld)(a[i]&msk)};
    fft(tr,len,d,0);tr[len]=tr[0];
    for(cmp* p1=tr,*p2=tr+len,*p3=op1;p1!=tr+len;++p1,--p2,++p3)
        (*p3)=(cmp){p1->r+p2->r,p1->v-p2->v}*(cmp){0.5,0};
    for(cmp* p1=tr,*p2=tr+len,*p3=op2;p1!=tr+len;++p1,--p2,++p3)
        (*p3)=(cmp){p1->r-p2->r,p1->v+p2->v}*(cmp){0,-0.5};
}inline void dbidft(cmp* tr,int len,int d,ll* a,ll* b)
{
    fft(tr,len,d,1);
    for(int i=0;i<len;i++)a[i]=(ll)(tr[i].r+0.5)%mod;
    for(int i=0;i<len;i++)b[i]=(ll)(tr[i].v+0.5)%mod;
}inline void poly_mul(ll* a,ll* b,ll* c,int len,int d)//以上都是任意模数fft的板子 
{
    dbdft(a,len,d,tr1,tr2);dbdft(b,len,d,tr3,tr4);
    for(int i=0;i<len;i++)tr5[i]=tr1[i]*tr3[i]+(cmp){0,1}*tr2[i]*tr4[i];
    for(int i=0;i<len;i++)tr6[i]=tr2[i]*tr3[i]+(cmp){0,1}*tr1[i]*tr4[i];
    dbidft(tr5,len,d,m13,m24);dbidft(tr6,len,d,m23,m14);
    for(int i=0;i<len;i++)c[i]=m13[i]*PP%mod;
    for(int i=0;i<len;i++)(c[i]+=(m23[i]+m14[i])*P+m24[i])%=mod;
}namespace iter
{
    ll f[N];ll g[N];ll h[N];ll ifac[N];
    inline void ih()
    {
        ifac[0]=ifac[1]=1;
        for(int i=2;i<min((ll)N,mod);i++)ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;
        for(int i=1;i<min((ll)N,mod);i++)(ifac[i]*=ifac[i-1])%=mod;
    }inline void calch(ll del,int cur,ll* ip,ll* op)
    {
        int d=0;int len=1;while(len<=cur+cur+cur)len<<=1,d++;
        for(int i=0;i<=cur;i++)f[i]=ip[i]*ifac[i]%mod*ifac[cur-i]%mod;
        for(int i=cur-1;i>=0;i-=2)f[i]=(mod-f[i])%mod;
        for(int i=0;i<=cur+cur;i++)g[i]=po((del+mod-cur+i)%mod,mod-2); 
        for(int i=cur+1;i<len;i++)f[i]=0;for(int i=cur+cur+1;i<len;i++)g[i]=0;
        poly_mul(f,g,h,len,d);//卷积求出h' 
        ll xs=1;ll p1=del-cur;ll p2=del;
        for(int i=p1;i<=p2;i++)(xs*=i)%=mod;
        for(int i=0;i<=cur;i++,p1++,p2++)//双指针求出系数 
        {
            op[i]=h[i+cur]*xs%mod;
            (xs*=po(p1,mod-2))%=mod,(xs*=(p2+1))%=mod;
        }  
    }
}ll val[N];ll fv1[N];ll fv2[N];
inline void solve(int n)//倍增 
{
    int hb=0;for(int p=n;p;p>>=1)hb++;val[0]=1;
    for(int z=hb,cur=0;z>=0;z--)
    {
        if(cur!=0)//把d乘2 
        {
            iter::calch(cur+1,cur,val,fv1);
            for(int i=0;i<=cur;i++)val[cur+i+1]=fv1[i];val[cur<<1|1]=0;
            iter::calch(cur*po(n,mod-2)%mod,cur<<1,val,fv2);
            cur<<=1;for(int i=0;i<=cur;i++)(val[i]*=fv2[i])%=mod;
        }if((n>>z)&1)//把d加1 
        {
            for(int i=0;i<=cur;i++)(val[i]*=(ll)(n*i)+cur+1)%=mod;cur|=1;val[cur]=1;
            for(int i=1;i<=cur;i++)(val[cur]*=(ll)cur*n+i)%=mod;
        }
    }
}
int main()
{
    pre();
    int t;
    scanf("%d",&t);
    while(t--)
        {
            int n;scanf("%d%lld",&n,&mod);iter::ih();
            int bl=sqrt(n);PP=(ll)P*P%mod;solve(bl);ll res=1;
            for(int i=0,id=0;;i+=bl,id++)//分块 
            {
                if((ll)i+bl>n)
                {
                    for(int j=i+1;j<=n;j++)
                        (res*=j)%=mod;
                    break;
                }
                (res*=val[id])%=mod;
            }
            printf("%lld\n",res);
        }
}
```



## 欧拉函数 

### 欧拉函数性质

$$
\sum_{d|n}\phi(d)=n
$$

> 狄利克雷卷积形式

$$
\phi*I=id\\
\rightarrow \phi * I * \mu= \phi * \epsilon =\phi = id * \mu\\
\phi(n)=\sum_{d|n}d\cdot \mu(\cfrac{n}{d})\\
\rightarrow \phi=id * \mu 
$$

> 杜教筛前置知识

$$
\cfrac{\phi(n)}{n}=\sum_{d|n}\cfrac{\mu(d)}{d}
$$

> 小结论

$$
\sum_{d\nmid n}d=n\cdot \cfrac{\phi(n)}{2}（n\neq 1）
$$

前者为一个数n，比它小、所有与n互素的值的和

### 单点欧拉函数值

>  O(sqrt(n))

欧拉函数是积性函数
$$
\phi(ab)=\phi(a)\phi(b)
$$


```c++
ll eular(ll n){
    ll ret=1,i;
    for (i=2;i*i<=n;i++)
        if (n%i==0){
            n/=i,ret*=i-1;
            while (n%i==0)
                n/=i,ret*=i;
        }
    if (n>1)
        ret*=n-1;
    return ret;
}
```

### 欧拉函数筛

$$
\phi(p_{j}^{w})=p_{j}^{w-1}\cdot(p_{j}-1)
$$



```c++
const int maxn=100000001;
int prime[maxn];      //就是个素数表
bool sf[maxn];        //判断这个数是不是素数，sf[i]中的i是从1到maxn的数
int phi[maxn];
void sushu(){         //核心 欧拉筛代码
    int num=0;        //num 用来记筛到第几个质数
    memset(sf,true,sizeof(sf));
  	phi[1]=1;
    for(int i=2;i<maxn;i++){          //外层枚举1~maxn
        if(sf[i]) prime[++num]=i,phi[i]=i-1;      //如果是质数就加入素数表
        for(int j=1;j<=num && i*prime[j]<maxn;j++){       //内层枚举num以内的质数
           // if(i*prime[j]>=maxn) break; //筛完结束
            sf[i*prime[j]]=false;      //筛掉...
            if(i%prime[j]==0){
            	phi[i*prime[j]]=phi[i]*prime[j];
              break;   //避免重复筛
            }
         		else phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    sf[1]=false;
    sf[0]=false;  //1 0 特判 
}
```

### 求$a^{x}\equiv1(mod\ n)$最小x解

```c++
#include <iostream>
#include <cmath>
using namespace std;
long long getOula_function(long long _mod){
    long long i,sum=_mod;
      for(i=2;i*i<=_mod;i++){
        if(!(_mod%i))    sum=(long long)sum*(1.0-1.0/i);
        while(!(_mod%i))    _mod/=i;
    }
    if(_mod!=1)    sum=(long long)sum*(1.0-1.0/_mod);
    return sum;
}
long long qPow_function(long long _x,long long _divisor,long long _mod){
    long long sum=1;
    while(_divisor){
        if(_divisor&1)    sum=sum*_x%_mod;
        _divisor=_divisor>>1;
        _x=_x*_x%_mod;
    }
    return sum;
}
long long getMinDiv(long long _base,long long _mod){
    long long _divisor=getOula_function(_mod);
    long long _flag=(long long)(log(_mod)/log(_base));
    long long _top=(long long)sqrt(_divisor);
    for(long long i=_flag+1;i<=_top;i++)
        if(!(_divisor%i) && qPow_function(_base,i,_mod)==1)    return i;
    for(long long i=_top;i>=1;i--)
        if(!(_divisor%i) && qPow_function(_base,_divisor/i,_mod)==1)    return _divisor/i;
}
```

## 杜教筛

低于线性时间复杂度计算积性函数前缀和

求$\sum_{i=1}^{n}f(i)$（f(i)为积性函数）
$$
构造两个积性函数h和g，使得h=f*g\\
让\sum_{i=1}^{n}h(i)能够容易求出\\
目标是求S(n)=\sum_{i=1}^{n}f(i)\\
\sum_{i=1}^{n}h(i)=\sum_{i=1}^{n}\sum_{d|i}g(d)\cdot f(\cfrac{i}{d})\\
=\sum_{d=1}^{n}g(d)\sum_{i=1}^{\lfloor \cfrac{n}{d} \rfloor } f(i)\\
=\sum_{d=1}^{n}g(d)\cdot S(\lfloor \cfrac{n}{d}\rfloor)\\
=g(1)*S(n)+\sum_{d=2}^{n}g(d)\cdot S(\lfloor \cfrac{n}{d}\rfloor)\\
\rightarrow g(1)S(n)=\sum_{i=1}^{n}h(i)-\sum_{d=2}^{n}g(d)\cdot S(\lfloor \cfrac{n}{d} \rfloor)
$$
其中h(i)=(f\*g)(i)，当h(i)的前缀和很好求时，对后面的式子整数分块，能$O(n^{\cfrac{2}{3}})$求出S(n)。（需要预处理出前m=$n^{\cfrac{2}{3}}$项值）

g和h的选取需要依靠经验

### 例子

> 杜教筛需要预处理出大约$\sqrt{maxn}$ 的答案，剩下部分分块计算(卡常可以选择一些数long long改int，取模会快)

1. 莫比乌斯函数前缀和$S(n)=\sum_{i=1}^{n}\mu(i)$

$g(1)S(n)=\sum_{i=1}^{n}(f*g)(i)-\sum_{d=2}^{n}g(d)\cdot S(\lfloor \cfrac{n}{d} \rfloor)$

由于$\mu*I=\epsilon$，所以选取g为积性函数$I$

$S(n)=1-\sum_{d=2}^{n}S(\lfloor \cfrac{n}{d} \rfloor)$

2. 欧拉函数前缀和$S(n)=\sum_{i=1}^{n} \phi(i)$

由于$\phi * I=id$，选取g=$I$

$S(n)=\sum_{i=1}^{n}i-\sum_{d=2}^{n}S(\lfloor \cfrac{n}{d} \rfloor)$

前者等差数列求和公式O(1)求，后半部分整数分块。

```c++
const int maxn=3e6+10;
int prime[maxn];
bool sf[maxn];
int mu[maxn];
int sum_mu[maxn];
int phi[maxn];
int sum_phi[maxn];
void init()
{
	int num=0;
	sf[0]=sf[1]=1;
	phi[1]=1;
	mu[1]=1;
	for(int i=2;i<maxn;++i)
	{
		if(!sf[i]) prime[++num]=i,mu[i]=-1,phi[i]=i-1;
		for(int j=1;j<=num;++j){
			if(i*prime[j]>=maxn) break;
			sf[i*prime[j]]=1;
			if(i%prime[j]==0) {
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
			mu[i*prime[j]]=-mu[i];
		}
	}
	sum_phi[0]=0;
	for(int i=1;i<maxn;++i)	{
		sum_mu[i]=sum_mu[i-1]+mu[i];
	}
	for(int i=1;i<maxn;++i){
		sum_phi[i]=sum_phi[i-1]+phi[i];
	}
}
unordered_map<int,int>summu_mp;
int djsmu(int x){
	if(x<maxn) return sum_mu[x];
	if(summu_mp.count(x)) return summu_mp[x];
	int ans=1;
	for(int L=2,R;L<=x;L=R+1){	//杜教筛的下界从2开始
		R=x/(x/L);
		ans=(ans-(R-L+1)*djsmu(x/L));
	}
	return summu_mp[x]=ans;
}

unordered_map<int,int>sumphi_mp;
int djsphi(int x){
	if(x<maxn) return sum_phi[x];
	if(sumphi_mp.count(x)) return sumphi_mp[x];
	int ans=(x+1)*x/2;
	for(int L=2,R;L<=x;L=R+1){	//杜教筛的下界从2开始
		R=x/(x/L);
		ans=(ans-(R-L+1)*djsphi(x/L));
	}
	return sumphi_mp[x]=ans;
}
```

3. $S(n)=\sum_{i=1}^{n}i\cdot \phi(i)$

考虑狄利克雷卷积形式

$\sum_{d|n}(d\cdot \phi(d))\cdot g(\cfrac{n}{d})$

我们看前面这个d不爽，就考虑为后面构造一个积性函数能够使这个d能够被约掉，尝试令g为$id$
$$
\sum_{d|n}(d\cdot \phi(d))\cdot \cfrac{n}{d}=\sum_{d|n}n\cdot \phi(d)\\
=n\sum_{d|n}\phi(d)=n^{2}
$$

```c++
const int maxn=3e6+10;
bool sf[maxn];
int prime[maxn];
int phi[maxn];
int sum[maxn];
int cnt=0;

void init()
{
	phi[1] =1;
	for(int i=2;i<maxn;i++)
		{
			if(!sf[i]){
				prime[++cnt]=i;
				phi[i]=i-1;
			}
			for(int j=1;j<=cnt && 1ll*i*prime[j]<maxn;j++){
				sf[i*prime[j]]=1;
				if(i%prime[j]==0){
					phi[i*prime[j]]=phi[i]*prime[j];
					break;
				}
				phi[i*prime[j]]=phi[i]*(prime[j]-1);
			}
		}
	sum[0]=0;
	for(int i=1;i<maxn;++i)
		sum[i]=(sum[i-1]+i*phi[i])%mod;
}

unordered_map<int,int> mp;
int inv2=power(2,mod-2),inv6=power(6,mod-2);

int djs(int x){
	if(x<maxn) return sum[x];
	if(mp.count(x)) return mp[x];
	int ans=x*(x+1)%mod*(2*x+1)%mod*inv6%mod;
	for(int l=2,r;l<=x;l=r+1){	//杜教筛的下界从2开始
		r=x/(x/l);
		ans=(ans-(l+r)*(r-l+1)/2%mod*djs(x/l)%mod+mod)%mod;
	}
	return mp[x]=ans;
}
```

类似有$f=i^{2}\phi(i)$，令$g=id^{2}$，有$f*g=h(n)=n^{3}$。

综上，记$f(i)=i^{k}\phi(i)$，有
$$
S(n)=\sum_{i=1}^{n}i^{k}\phi(i)\\
=\sum_{i=1}^{n}f(i)=\sum_{i=1}^{n}i^{k+1}-\sum_{i=2}^{n}i^{k}S(\lfloor\cfrac{n}{i}\rfloor)
$$


## 整数分块	O(sqrt(n))

求1~n的n/i（下取整）的总和：

我们会发现：总会有很多的(n/l)~(n/r)的值是重复的，所以我们可以寻找这样的区间；

即：n/i=n/(i+d)	（i是左下界，(i+d)max是右上界）

我们要干的就是在O(1)的时间复杂度内找出这个d
$$
设\lfloor \cfrac{n}{i} \rfloor=k ，则\ ki+p=n, 设\lfloor \cfrac{n}{i+d} \rfloor=k,则\ k(i+d)+q=n \\
易得\ q=p-kd,\ d=\lfloor \cfrac{q-p}{k} \rfloor。\\
当\ p=0时，d最大值为\lfloor \cfrac{q}{k} \rfloor ，\\
(i+d)_{max}=i+d_{max}=i+\lfloor \cfrac{q}{k} \rfloor =i+\lfloor \cfrac{n\%i}{\lfloor \cfrac{n}{i} \rfloor} \rfloor\\
=i+ \lfloor \cfrac {n-\lfloor \cfrac{n}{i}\rfloor \cdot i}{\lfloor \cfrac{n}{i} \rfloor}\rfloor \\
=\lfloor i+ \cfrac {n-\lfloor \cfrac{n}{i}\rfloor \cdot i}{\lfloor \cfrac{n}{i} \rfloor}\rfloor \\
=\lfloor \cfrac {n}{\lfloor \cfrac{n}{i}\rfloor}\rfloor
$$

```c++
for(int L=1,R;L<=n;L=R+1){
  R=n/(n/L);
  ans+=(n/L)*(R-L+1)*(L+R)/2;
}
```

二维分块,求：
$$
\sum_{i=1}^{min(n,m)}\lfloor\cfrac{n}{i}\rfloor\lfloor\cfrac{m}{i}\rfloor
$$

```c++
for(int L=1,R;L<=n;L=R+1){
  R=min(n/(n/i),m/(m/i));
  ans+=(n/L)*(m/L)*(r-l+1);
}
```

## BSGS

> 求解$a^{x}\equiv b\ (\ mod\ p\ )$，$O(\sqrt{p})$

令$x=A\lceil\sqrt{p}\rceil-B$，其中$0\leq A,B \leq \lceil\sqrt{p}\rceil$，则有$a^{A\lceil\sqrt{p}\rceil-B}\equiv b(mod\ p)$，变换，有$a^{A\lceil\sqrt{p}\rceil}\equiv ba^{B}(mod\ p)$。

已知a,b，先算出右边所有的$ba^{B}$所有取值，枚举B，用hash/map存下来，然后逐个计算$a^{A\lceil\sqrt{p}\rceil}$，枚举A，寻找相等的$ba^{B}$，从而得到所有的x，$x=A\lceil\sqrt{p}\rceil-B$。

```c++
//求a^x mod p = b  其中 (y,p)=1的最小的x O（sqrt(p)） 使用map多log
ll BSGS(ll a,ll b,ll p) {
    if(!a) return b?-1:1;
    if(b==1) return 0;
    unordered_map<ll,ll>mp;
    int m=ceil(sqrt(p)),ax=1;
    for(int i=0; i<m; i++) {///a^0 ... a^(m-1)
        mp[ax]=i; ///可提前 return 
        ax=ax*a%p;
    }
    ll am=quick(a,m);
    am=quick(am,mod-2);
    for(int i=0;i<m;++i) {///a^(im+j)
        if(mp.count(b)) return m*i+mp[b];
        b=b*am%p;
    }
    return -1;
}
```

![ExBSGS](/Users/davidxu/Desktop/算法笔记md/math_pic/ExBSGS.png)

> $O(logb+\sqrt{p})$

```c++
map<int,int>H;
int exBSGS(ll a,ll b,ll p) {
    H.clear();
    ll d=1,g=0,gcd; b%=p;
    if(b==1 || p==1) return 0;
    while((gcd=__gcd(a,p))^1) {
        if(b%gcd) return -1;
        b/=gcd; p/=gcd; d*=(a/gcd); d%=p; g++;
        if(d==b) return g;
    }
    int t=ceil(sqrt(p*1.0));
    ll now=1,x,y,tmpg;
    ex_gcd(d,p,tmpg,x,y);
    x=(x%p+p)%p;
    b*=x; b%=p; now=b;
    for (int i=0;i<t;++i,now*=a,now%=p) H[now]=i;
    int powt=quick(a,t,p); now=powt;
    for(int i=t;i<=t*t;i+=t,now*=powt,now%=p) if(H.find(now)!=H.end()) return i-H[now]+g;
    return -1;
}
```

> 超快版本

```c++
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
const long long maxn=1e5,mod=1145141,inf=0xffffffffffffffll;//mod用来哈希
long long base,rest,prime,baby[maxn+1],giant[maxn+1],key[mod],comment[2][mod],stk[mod<<1|1];
long long Hash(long long value)
{
	long long now=value*value%mod;
	while(key[now]&&key[now]!=value)
		now=(now+1)%mod;
	if(!key[now])
		stk[++stk[0]]=now;
	key[now]=value;
	return now;
}
long long phi(long long x)
{
	long long res=x;
	for(long long i=2;i*i<=x;++i)
		if(x%i==0)
		{
			res=res/i*(i-1);
			while(x%i==0)
				x/=i;
		}
	if(x>1)
		res=res/x*(x-1);
	return res;
}
long long exBSGS(void)
{
	long long res=inf,block=ceil(sqrt(2*phi(prime)));
	baby[0]=1;
	for(long long i=1;i<=block;++i)
		baby[i]=baby[i-1]*base%prime;
	comment[0][Hash(1)]=0;
	giant[0]=1;
	for(long long i=1;i<=block;++i)
	{
		giant[i]=giant[i-1]*baby[block]%prime;
		long long now=Hash(giant[i]);
		if(!comment[0][now])
			comment[0][now]=i;
		else if(!comment[1][now])
			comment[1][now]=i;
	}
	for(long long i=0;i<=block;++i)
	{
		long long now=Hash(rest*baby[i]%prime),t0=comment[0][now],t1=comment[1][now];
		if(t0&&giant[t0-1]*baby[block-i]%prime==rest)
			res=min(res,t0*block-i);
		else if(t1&&giant[t1-1]*baby[block-i]%prime==rest)
			res=min(res,t1*block-i);
	}
	return res;
}
signed main()
{
	while(scanf("%lld%lld%lld",&base,&prime,&rest)!=EOF)	//对应a,p,b
	{
		while(stk[0])
		{
			key[stk[stk[0]]]=comment[0][stk[stk[0]]]=comment[1][stk[stk[0]]]=0;
			--stk[0];
		}
		if(!prime&&!base&&!rest)
			break;
		base%=prime;
		rest%=prime;
		long long res=exBSGS();
		if(res==inf)
			puts("No Solution");
		else printf("%lld\n",res);
	}
	return 0;
}
```

> 求解$x^{a}\equiv b(mod\ p)$，p是质数

p是质数，那么p一定存在一个原根g，使得模p意义下，$x(0\leq x<p)$有且仅有一个数$i(0\leq i< p-1)$满足，$x=g^{i}$。

法一：令$x=g^{c}$，g是p的原根（需要求出），问题转化为求解$(g^{a})^{c}\equiv\ b(mod\ p)$，可以在$O(\sqrt{p})$解出c，由此可以得到一组特解$x_{0}\equiv g^{c}(mod\ p)$。

法二：处理方法类似，利用BSGS求出t，使得$g^{t}\equiv b(mod\ p)$，随后可以得到$g^{ac}\equiv g^{t}(mod\ p)$，两边取离散对数，得到$ac\equiv t(mod\ \phi(p))$。

得到一组特解时，可以得到所有解
$$
\forall t\in Z,x^{a}\equiv g^{c\cdot a+t\cdot \phi(p)}\equiv b(mod\ p)\\
\forall t\in Z,\ a|t\cdot \phi(p),\ x\equiv g^{c+\cfrac{t\cdot \phi(p)}{a}}(mod\ p)\\
显然有\cfrac{a}{gcd(a,\phi(p))\ |\ t}，因此设\ t=\cfrac{a}{gcd(a,\phi(p))}\cdot i，得到\\
\forall i \in Z,x\equiv g^{c+\cfrac{\phi(p)}{gcd(a,\phi(p))}\cdot i}(mod\ p)
$$

## 类欧几里得

$$
\sum_{x=0}^{n}x^{k1}\lfloor\cfrac{ax+b}{c}\rfloor^{k2}
$$

>  可读性比较高的板子

```c++
//万能类欧
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 15, M = 1e9 + 7;
int f[100][N][N], C[N][N], A[N][N], k1, k2, a, b, c, n, T;
int ksm(int x, int y)
int S(int n, int m) {
    int s = 0;
    for (int i = 0, v = 1; i <= m + 1; i++, (v *= n) %= M)
        (s += A[m][i] * v) %= M;

    return s;
}
int solve(int k1, int k2, int a, int b, int c, int n, int dep) {
    if (f[dep][k1][k2] != -1)
        return f[dep][k1][k2];
    int v = 0;
    if (a == 0)return f[dep][k1][k2] = S(n, k1) * ksm(b / c, k2) % M;
    if (a >= c || b >= c) {
        for (int i = 0; i <= k2; i++)
            for (int j = 0; j <= k2 - i; j++) {
                int k = k2 - i - j;
                (v += C[k2][i] * C[k2 - i][j] % M * ksm(a / c, i) % M * ksm(b / c, j) % M * solve(k1 + i, k, a % c, b % c, c,
                        n, dep + 1)) %= M;
            }

        return f[dep][k1][k2] = v;
    }

    int m = (a * n + b) / c - 1;
    v = S(n, k1) * ksm(m + 1, k2) % M;

    for (int i = 0; i <= k2 - 1; i++)
        for (int j = 0; j <= k1 + 1; j++)
            (v += M - C[k2][i] * A[k1][j] % M * solve(i, j, c, c - b - 1, a, m, dep + 1) % M) %= M;

    return f[dep][k1][k2] = v;
}
signed main() {
    scanf("%lld", &T);
    C[0][0] = 1;
    for (int i = 1; i < N; i++) {
        C[i][0] = 1;
        for (int j = 1; j <= i; j++)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % M;
    }
    A[0][1] = A[0][0] = 1;
    for (int i = 1; i < N - 1; i++) {
        for (int j = 0; j <= i + 1; j++)
            A[i][j] = C[i + 1][j];
        for (int j = 0; j < i; j++)
            for (int k = 0; k <= j + 1; k++)
                (A[i][k] += M - C[i + 1][j] * A[j][k] % M) %= M;
        int Inv = ksm(i + 1, M - 2);
        for (int j = 0; j <= i + 1; j++)
            (A[i][j] *= Inv) %= M;
    }
    while (T--) {
        scanf("%lld%lld%lld%lld%lld%lld", &n, &a, &b, &c, &k1, &k2);
        memset(f, -1, sizeof f);
        printf("%lld\n", solve(k1, k2, a, b, c, n, 0));
    }
}
```

> 超快的板子

```c++
#pragma GCC optimize ("O3")
#pragma GCC target ("avx")
#include <cstdio>
#include <cassert>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <functional>
#include <stack>
#include <queue>
#include <tuple>
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#define _rep(_1, _2, _3, _4, name, ...) name
#define rep2(i, n) rep3(i, 0, n)
#define rep3(i, a, b) rep4(i, a, b, 1)
#define rep4(i, a, b, c) for (int i = int(a); i < int(b); i += int(c))
#define rep(...) _rep(__VA_ARGS__, rep4, rep3, rep2, _)(__VA_ARGS__)
using namespace std;
using i64 = long long;
using u8 = unsigned char;
using u32 = unsigned;
using u64 = unsigned long long;
using f80 = long double;
int get_int() {
    int c, n;
    while ((c = getchar()) < '0');
    n = c - '0';
    while ((c = getchar()) >= '0')
        n = n * 10 + (c - '0');
    return n;
}
const int K = 10;
const int mod = 1e9 + 7;
const i64 lmod = i64(mod) << 32;
const int signs[2] = {1, mod - 1};
int invs[K + 2], binom[K + 2][K + 2], B[K + 1], polys[K + 1][K + 2];
int add(int a, int b) {
    return (a += b - mod) < 0 ? a + mod : a;
}
i64 add64(i64 a, i64 b) {
    return (a += b - lmod) < 0 ? a + lmod : a;
}
int mul(int a, int b) {
    return i64(a) * b % mod;
}
int power_sum(int e, int x) {
    int ret = 0;
    for (int i = 0; i < e + 2; ++i)
        ret = add(mul(ret, x), polys[e][i]);
    return mul(ret, invs[e + 1]);
}
void init() {
    invs[0] = invs[1] = 1;
    for (int i = 2; i <= K + 1; ++i)
        invs[i] = mul(invs[mod % i], mod - mod / i);
    for (int i = 0; i <= K + 1; ++i) {
        binom[i][0] = 1;
        for (int j = 1; j <= i; ++j)
            binom[i][j] = add(binom[i - 1][j - 1], binom[i - 1][j]);
    }
    B[0] = 1;
    for (int i = 1; i <= K; ++i) {
        int s = 0;
        for (int j = 0; j < i; ++j)
            s = add(s, mul(binom[i + 1][j], B[j]));
        B[i] = mul(mul(s, invs[i + 1]), signs[1]);
    }
    for (int i = 0; i <= K; ++i) {
        for (int j = 0; j <= i; ++j)
            polys[i][j] = mul(mul(binom[i + 1][j], B[j]), signs[j & 1]);
        polys[i][i + 1] = 0;
    }
    polys[0][1] = 1;
}
int scary_sum(int N, int a, int b, int c, int e1, int e2) {
    assert(N >= 0);
    assert(a >= 0);
    assert(b >= 0);
    assert(c >= 1);
    assert(e1 + e2 <= K);
    using T = tuple<int, int, int, int>;
    stack<T> stac;
    while (1) {
        stac.emplace(N, a, b, c);
        if (N < 0 || a == 0)
            break;
        if (a >= c) {
            a %= c;
        } else if (b >= c) {
            b %= c;
        } else {
            N = (i64(a) * N + b) / c - 1;
            b = c - 1 - b;
            swap(a, c);
        }
    }
    const int S = e1 + e2;
    static int curr[K + 1][K + 1] = {}, next[K + 1][K + 1] = {};
    while (!stac.empty()) {
        tie(N, a, b, c) = stac.top();
        stac.pop();
        if (N < 0) {
            ;
        } else if (a == 0) {
            int q = b / c;
            for (int e1 = 0; e1 <= S; ++e1) {
                int s = power_sum(e1, N);
                for (int e2 = 0; e2 <= S - e1; ++e2)
                    next[e1][e2] = s, s = mul(s, q);
            }
        } else if (a >= c || b >= c) {
            int q = (a >= c) ? a / c : b / c;
            int d = (a >= c) ? 1 : 0;
            for (int e1 = 0; e1 <= S; ++e1) {
                for (int e2 = 0; e2 <= S - e1; ++e2) {
                    i64 s = 0;
                    int p = 1;
                    for (int i2 = 0; i2 <= e2; ++i2) {
                        s = add64(s, i64(p) * mul(binom[e2][i2], curr[e1 + i2 * d][e2 - i2]));
                        p = mul(p, q);
                    }
                    next[e1][e2] = s % mod;
                }
            }
        } else {
            static int cumu[K + 1][K + 1];
            for (int e2 = 0; e2 <= S - 1; ++e2) {
                for (int e1 = 0; e1 <= S - e2 - 1; ++e1) {
                    i64 s = 0;
                    for (int j = 0; j <= e1 + 1; ++j) {
                        s = add64(s, i64(polys[e1][e1 + 1 - j]) * curr[e2][j]);
                    }
                    cumu[e1][e2] = mul(s % mod, invs[e1 + 1]);
                }
            }
            const int M = (i64(a) * N + b) / c;
            for (int e1 = 0; e1 <= S; ++e1) {
                int p = power_sum(e1, N);
                for (int e2 = 0; e2 <= S - e1; ++e2) {
                    i64 t = 0;
                    for (int i2 = 0; i2 < e2; ++i2) {
                        t = add64(t, i64(cumu[e1][i2]) * binom[e2][i2]);
                    }
                    next[e1][e2] = add(p, mod - t % mod);
                    p = mul(p, M);
                }
            }
        }
        swap(curr, next);
    }
    return curr[e1][e2];
}
void solve() {
    init();
    int T = get_int();
    rep(_, T) {
        int N = get_int(), a = get_int(), b = get_int(), c = get_int();
        int e1 = get_int(), e2 = get_int();
        printf("%d\n", scary_sum(N, a, b, c, e1, e2));
    }
}
int main() {
    clock_t beg = clock();
    solve();
    clock_t end = clock();
    fprintf(stderr, "%.3f sec\n", double(end - beg) / CLOCKS_PER_SEC);
    return 0;
}
```

# 二项式展开

$$
(a+b)^{n}=\sum_{r=0}^nC_{n}^{r}a^{n-r}b^{r}
$$

# 快速傅立叶变换（FFT）

> 模板一，常数不是一点点大，多组数据很容易T，慎用

```c++
vector<int> r;	//当vector用就行了
constexpr ll g = 3;
ll power(ll x,ll y){
    ll res=1;
    for(;y;y>>=1,x=x*x%mod)
        if(y&1)res=res*x%mod;
    return res;
}
struct Poly : vector<ll>{
    Poly(){}
    Poly(int n) : vector<ll>(n){}
    Poly(const initializer_list<ll>& list) : vector<ll>(list){}
    void dft(int n, bool inverse = false){
        if((int)r.size() != n){
            r.resize(n);
            r[1] = n >> 1;
            for(int i = 2; i < n; i += 1) r[i] = r[i >> 1] >> 1 | (i & 1 ? n >> 1 : 0);
        }
        resize(n);
        for(int i = 0; i < n; i += 1) if(i < r[i]) std::swap(at(i), at(r[i]));
        for(int d = 0; (1 << d) < n; d += 1){
            int m = 1 << d, m2 = m << 1;
            ll _w = power(inverse ? power(g, mod - 2) : g, (mod - 1) / m2);
            for(int i = 0; i < n; i += m2)
                for(int w = 1, j = 0; j < m; j += 1, w = w * _w % mod){
                    ll& x = at(i + j + m), &y = at(i + j), t = w * x % mod;
                    x = y - t;
                    if(x < 0) x += mod;
                    y += t;
                    if(y >= mod) y -= mod;
                }
        }
        if(inverse) for(int i = 0, inv = power(n, mod - 2); i < n; i += 1) at(i) = at(i) * inv % mod;
    }
    Poly operator * (const Poly& p)const{
        auto a = *this, b = p;
        int k = 1, n = size() + p.size() - 1;
        while(k < n) k <<= 1;
        a.dft(k);
        b.dft(k);
        for(int i = 0; i < k; i += 1) a[i] = a[i] * b[i] % mod;
        a.dft(k, true);
        a.resize(n);
        return a;
    }
    Poly inverse()const{
        Poly a = {power(at(0), mod - 2)};
        for(int n = 1; n < (int)size(); n <<= 1){
            int k = n << 2;
            auto b = *this, c = a;
            for(int i = n << 1; i < (int)b.size(); i += 1) b[i] = 0;
            b.dft(k);
            c.dft(k);
            for(int i = 0; i < k; i += 1) b[i] = b[i] * c[i] % mod * c[i] % mod;
            b.dft(k, true);
            a.resize(n << 1);
            for(int i = 0; i < (n << 1); i += 1) a[i] = (2 * a[i] + mod - b[i]) % mod;
        }
        a.resize(size());
        return a;
    }
    pair<Poly, Poly> operator / (const Poly& p){
        int n = size() - p.size() + 1;
        auto a = *this, b = p;
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        a.resize(n);
        b.resize(n);
        auto q = a * b.inverse();
        q.resize(n);
        reverse(q.begin(), q.end());
        auto r = p * q;
        r.resize(p.size() - 1);
        for(int i = 0; i + 1 < (int)p.size(); i += 1){
            r[i] = at(i) - r[i];
            if(r[i] < 0) r[i] += mod;
        }
        return {q, r};
    }
    Poly log()const{
        int n = size();
        Poly a(n - 1);
        for(int i = 0; i + 1 < n; i += 1) a[i] = at(i + 1) * (i + 1) % mod;
        a = a * inverse();
        a.resize(n);
        for(int i = n - 1; i >= 0; i -= 1) a[i] = i ? a[i - 1] * power(i, mod - 2) % mod : 0;
        return a;
    }
    Poly exp()const{
        Poly a = {1};
        for(int n = 1; n < (int)size(); n <<= 1){
            int k = n << 2;
            auto b = a.log();
            b.resize(k);
            for(int i = 0; i < k; i += 1)
                b[i] = ((i < (int)size() ? at(i) : 0) + not i + mod - b[i]) % mod;
            a = a * b;
            a.resize(k);
        }
        a.resize(size());
        return a;
    }
    Poly mulT(const Poly& p)const{
        auto a = *this;
        reverse(a.begin(), a.end());
        a = a * p;
        a.resize(size());
        reverse(a.begin(), a.end());
        return a;
    }
    Poly eval(const Poly& x)const{
        #define tm ((tl + tr) >> 1)
        #define ls (v << 1)
        #define rs (ls | 1)
        vector<Poly> Q(x.size() << 2), P(x.size() << 2);
        Poly y(x.size());
        function<void(int, int, int)> dfs1 = [&](int v, int tl, int tr){
            if(tl == tr){
                Q[v].push_back(1);
                Q[v].push_back((mod - x[tm]) % mod);
                return;
            }
            dfs1(ls, tl, tm);
            dfs1(rs, tm + 1, tr);
            Q[v] = Q[ls] * Q[rs];
        };
        function<void(int, int, int)> dfs2 = [&](int v, int tl, int tr){
            if(tl == tr){
                y[tm] = P[v][0];
                return;
            }
            P[v].resize(tr - tl + 1);
            P[ls] = P[v].mulT(Q[rs]);
            P[rs] = P[v].mulT(Q[ls]);
            dfs2(ls, tl, tm);
            dfs2(rs, tm + 1, tr);
        };
        dfs1(1, 0, x.size() - 1);
        Q[1].resize(max(size(), x.size()));
        P[1] = mulT(Q[1].inverse());
        dfs2(1, 0, x.size() - 1);
        return y;
    }
};
```

> 模板二

<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/Poly模板二说明.png" alt="Poly模板二说明" style="zoom:50%;" />

```c++
namespace Polynomial {
using Poly = std::vector<int>;
constexpr int P(998244353), G(3);
inline void inc(int &x, int y) { (x += y) >= P ? x -= P : 0; }
inline int mod(int64_t x) { return x % P; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k >>= 1, x = 1LL * x * x % P)
    if (k & 1) r = 1LL * r * x % P;
  return r;
}
template <int N>
std::array<int, N> getOmega() {
  std::array<int, N> w;
  for (int i = N >> 1, x = fpow(G, (P - 1) / N); i; i >>= 1, x = 1LL * x * x % P) {
    w[i] = 1;
    for (int j = 1; j < i; j++) w[i + j] = 1LL * w[i + j - 1] * x % P;
  }
  return w;
}
auto w = getOmega<1 << 20>();
Poly &operator*=(Poly &a, int b) { for (auto &x : a) x = 1LL * x * b % P; return a; }
Poly operator*(Poly a, int b) { return a *= b; }
Poly operator*(int a, Poly b) { return b * a; }
Poly &operator/=(Poly &a, int b) { return a *= fpow(b); }
Poly operator/(Poly a, int b) { return a /= b; }
Poly &operator+=(Poly &a, Poly b) {
  a.resize(std::max(a.size(), b.size()));
  for (int i = 0; i < b.size(); i++) inc(a[i], b[i]);
  return a;
}
Poly operator+(Poly a, Poly b) { return a += b; }
Poly &operator-=(Poly &a, Poly b) {
  a.resize(std::max(a.size(), b.size()));
  for (int i = 0; i < b.size(); i++) inc(a[i], P - b[i]);
  return a;
}
Poly operator-(Poly a, Poly b) { return a -= b; }
Poly operator-(Poly a) { for (auto &x : a) x ? x = P - x : 0; return a; }
Poly &operator>>=(Poly &a, int x) {
  if (x >= (int)a.size()) {
    a.clear();
  } else {
    a.erase(a.begin(), a.begin() + x);
  }
  return a;
}
Poly &operator<<=(Poly &a, int x) {
  a.insert(a.begin(), x, 0);
  return a;
}
Poly operator>>(Poly a, int x) { return a >>= x; }
Poly operator<<(Poly a, int x) { return a <<= x; }
inline Poly &dotEq(Poly &a, Poly b) {
  assert(a.size() == b.size());
  for (int i = 0; i < a.size(); i++) a[i] = 1LL * a[i] * b[i] % P;
  return a;
}
inline Poly dot(Poly a, Poly b) { return dotEq(a, b); }
void norm(Poly &a) {
  if (!a.empty()) {
    a.resize(1 << std::__lg(a.size() * 2 - 1));
  }
}
void dft(int *a, int n) {
  assert((n & n - 1) == 0);
  for (int k = n >> 1; k; k >>= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = 1LL * (a[i + j] - y + P) * w[k + j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void idft(int *a, int n) {
  assert((n & n - 1) == 0);
  for (int k = 1; k < n; k <<= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[k + j] % P;
        a[i + j + k] = x - y < 0 ? x - y + P : x - y;
        inc(a[i + j], y);
      }
    }
  }
  for (int i = 0, inv = P - (P - 1) / n; i < n; i++)
    a[i] = 1LL * a[i] * inv % P;
  std::reverse(a + 1, a + n);
}
void dft(Poly &a) { dft(a.data(), a.size()); }
void idft(Poly &a) { idft(a.data(), a.size()); }
Poly operator*(Poly a, Poly b) {
  int len = a.size() + b.size() - 1;
  if (a.size() <= 8 || b.size() <= 8) {
    Poly c(len);
    for (size_t i = 0; i < a.size(); i++)
      for (size_t j = 0; j < b.size(); j++)
        c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;
    return c;
  }
  int n = 1 << std::__lg(len - 1) + 1;
  a.resize(n), b.resize(n);
  dft(a), dft(b);
  dotEq(a, b);
  idft(a);
  a.resize(len);
  return a;
}
Poly invRec(Poly a) {
  int n = a.size();
  assert((n & n - 1) == 0);
  if (n == 1) return {fpow(a[0])};
  int m = n >> 1;
  Poly b = invRec(Poly(a.begin(), a.begin() + m)), c = b;
  b.resize(n);
  dft(a), dft(b), dotEq(a, b), idft(a);
  for (int i = 0; i < m; i++) a[i] = 0;
  for (int i = m; i < n; i++) a[i] = P - a[i];
  dft(a), dotEq(a, b), idft(a);
  for (int i = 0; i < m; i++) a[i] = c[i];
  return a;
}
Poly inverse(Poly a) {
  int n = a.size();
  norm(a);
  a = invRec(a);
  a.resize(n);
  return a;
}
Poly operator/(Poly a, Poly b) {  // return: c(len = n - m + 1), a = b * c + r
  int n = a.size(), m = b.size();
  if (n < m) return {0};
  int k = 1 << std::__lg(n - m << 1 | 1);
  std::reverse(a.begin(), a.end());
  std::reverse(b.begin(), b.end());
  a.resize(k), b.resize(k), b = invRec(b);
  a = a * b;
  a.resize(n - m + 1);
  std::reverse(a.begin(), a.end());
  return a;
}
std::pair<Poly, Poly> operator%(Poly a, Poly b) {  // return: {c(len = n - m + 1), r(len = m - 1)}
  int m = b.size();
  Poly c = a / b;
  b = b * c;
  a.resize(m - 1);
  for (int i = 0; i < m - 1; i++) inc(a[i], P - b[i]);
  return {c, a};
}
Poly sqrt(Poly a) {
  int raw = a.size();
  int d = 0;
  while (d < raw && !a[d]) d++;
  if (d == raw) return a;
  if (d & 1) return {};
  norm(a >>= d);
  int len = a.size();  
  Poly b(len), binv(1), bsqr{a[0]}, foo, bar;  // sqrt, sqrt_inv, sqrt_sqr
  auto sq = SqrtMod::sqrtMod(a[0], P);
  if (sq.empty()) return {};
  b[0] = sq[0], binv[0] = fpow(b[0]);
  auto shift = [](int x) { return (x & 1 ? x + P : x) >> 1; };  // quick div 2
  for (int m = 1, n = 2; n <= len; m <<= 1, n <<= 1) {
    foo.resize(n), bar = binv;
    for (int i = 0; i < m; i++) {
      foo[i + m] = a[i] + a[i + m] - bsqr[i];
      if (foo[i + m] >= P) foo[i + m] -= P;
      if (foo[i + m] < 0) foo[i + m] += P;
      foo[i] = 0;
    }
    binv.resize(n);
    dft(foo), dft(binv), dotEq(foo, binv), idft(foo);
    for (int i = m; i < n; i++) b[i] = shift(foo[i]);
    // inv
    if (n == len) break;
    for (int i = 0; i < n; i++) foo[i] = b[i];
    bar.resize(n), binv = bar;
    dft(foo), dft(bar), bsqr = dot(foo, foo), idft(bsqr);
    dotEq(foo, bar), idft(foo);
    for (int i = 0; i < m; i++) foo[i] = 0;
    for (int i = m; i < n; i++) foo[i] = P - foo[i];
    dft(foo), dotEq(foo, bar), idft(foo);
    for (int i = m; i < n; i++) binv[i] = foo[i];
  }
  b <<= d / 2;
  b.resize(raw);
  return b;
}
Poly deriv(Poly a) {
  for (int i = 0; i + 1 < a.size(); i++) a[i] = (i + 1LL) * a[i + 1] % P;
  a.pop_back();
  return a;
}
std::vector<int> inv = {1, 1};
void updateInv(int n) {
  if ((int)inv.size() <= n) {
    int p = inv.size();
    inv.resize(n + 1);
    for (int i = p; i <= n; i++) inv[i] = 1LL * (P - P / i) * inv[P % i] % P;
  }
}
Poly integ(Poly a, int c = 0) {
  int n = a.size();
  updateInv(n);
  Poly b(n + 1);
  b[0] = c;
  for (int i = 0; i < n; i++) b[i + 1] = 1LL * inv[i + 1] * a[i] % P;
  return b;
}
Poly ln(Poly a) {
  int n = a.size();
  assert(a[0] == 1);
  a = inverse(a) * deriv(a);
  a.resize(n - 1);
  return integ(a);
}
// newton
// $O(n \log n)$, slower than exp2
Poly expNewton(Poly a) {
  int n = a.size();
  assert((n & n - 1) == 0);
  assert(a[0] == 0);
  if (n == 1) return {1};
  int m = n >> 1;
  Poly b = expNewton(Poly(a.begin(), a.begin() + m)), c;
  b.resize(n), c = ln(b);
  a.resize(n << 1), b.resize(n << 1), c.resize(n << 1);
  dft(a), dft(b), dft(c);
  for (int i = 0; i < n << 1; i++) a[i] = (1LL + P + a[i] - c[i]) * b[i] % P;
  idft(a);
  a.resize(n);
  return a;
}
// half-online conv
// $O(n\log^2n)$
// $b = e^a, b' = a'b$
// $(n+1)b_{n+1} = \sum_{i=0}^n a'_ib_{n-i}$
// $nb_n = \sum_{i=0}^{n-1} a'_ib_{n - 1 - i}$
Poly exp2(Poly a) { 
  if (a.empty()) return {};
  assert(a[0] == 0);
  int n = a.size();
  updateInv(n);
  for (int i = 0; i + 1 < n; i++) {
    a[i] = a[i + 1] * (i + 1LL) % P;
  }
  a.pop_back();
  Poly b(n);
  b[0] = 1;
  for (int m = 1; m < n; m++) {
    int k = m & -m, l = m - k, r = std::min(m + k, n);
    Poly p(a.begin(), a.begin() + (r - l - 1));
    Poly q(b.begin() + l, b.begin() + m);
    p.resize(k * 2), q.resize(k * 2);
    dft(p), dft(q);
    dotEq(p, q);
    idft(p);
    for (int i = m; i < r; i++) inc(b[i], p[i - l - 1]);
    b[m] = 1LL * b[m] * inv[m] % P;
  }
  return b;
}
// half-online conv
// $O(\frac{n\log^2n}{\log\log n})$
// $nb_n = \sum_{i=0}^{n-1} a'_ib_{n - 1 - i}$
Poly exp(Poly a) {
  if (a.empty()) return {};
  assert(a[0] == 0);
  int n = a.size();
  updateInv(n);
  for (int i = 0; i + 1 < n; i++) {
    a[i] = a[i + 1] * (i + 1LL) % P;
  }
  a.pop_back();
  Poly b(n);
  b[0] = 1;
  std::vector<Poly> val_a[6], val_b(n);
  for (int m = 1; m < n; m++) {
    int k = 1, d = 0;
    while (!(m / k & 0xf)) k *= 16, d++;
    int l = m & ~(0xf * k), r = std::min(n, m + k);
    if (k == 1) {
      for (int i = m; i < r; i++) {
        for (int j = l; j < m; j++) {
          b[i] = (b[i] + 1LL * b[j] * a[i - j - 1]) % P;
        }
      }
    } else {
      assert(d < 6);
      if (val_a[d].empty()) val_a[d].resize(n);
      val_b[m] = Poly(b.begin() + (m - k), b.begin() + m);
      val_b[m].resize(k * 2);
      dft(val_b[m]);
      Poly res(k * 2);
      for (; l < m; l += k) {
        auto &p = val_a[d][m - l - k];
        if (p.empty()) {
          p = Poly(a.begin() + (m - l - k), a.begin() + (r - l - 1));
          p.resize(2 * k);
          dft(p);
        }
        auto &q = val_b[l + k];
        for (int i = 0; i < k * 2; i++) res[i] = (res[i] + 1LL * p[i] * q[i]) % P;
      }
      idft(res);
      for (int i = m; i < r; i++) inc(b[i], res[i - m + k - 1]);
    }
    b[m] = 1LL * b[m] * inv[m] % P;
  }
  return b;
}
Poly power(Poly a, int k) {
  int n = a.size();
  long long d = 0;
  while (d < n && !a[d]) d++;
  if (d == n) return a;
  a >>= d;
  int b = fpow(a[0]);
  norm(a *= b);
  a = exp(ln(a) * k) * fpow(b, P - 1 - k % (P - 1));
  a.resize(n);
  d *= k;
  for (int i = n - 1; i >= d; i--) a[i] = a[i - d];
  d = std::min(d, 1LL * n);
  for (int i = d; i; a[--i] = 0) ;
  return a;
}
Poly power(Poly a, int k1, int k2) { // k1 = k % (P - 1), k2 = k % P
  int n = a.size();
  long long d = 0;
  while (d < n && !a[d]) d++;
  if (d == n) return a;
  a >>= d;
  int b = fpow(a[0]);
  norm(a *= b);
  a = exp(ln(a) * k2) * fpow(b, P - 1 - k1 % (P - 1));
  a.resize(n);
  d *= k1;
  for (int i = n - 1; i >= d; i--) a[i] = a[i - d];
  d = std::min(d, 1LL * n);
  for (int i = d; i; a[--i] = 0) ;
  return a;
}
// [x^n](f / g)
// $O(m \log m \log n)$
int divAt(Poly f, Poly g, int64_t n) { 
  assert(f.size() == g.size());
  int len = f.size(), m = 1 << std::__lg(len * 2 - 1);
  for (; n; n >>= 1) {
    f.resize(m * 2), g.resize(m * 2);
    dft(f), dft(g);
    for (int i = 0; i < m * 2; i++) f[i] = 1LL * f[i] * g[i ^ 1] % P;
    for (int i = 0; i < m; i++) g[i] = 1LL * g[i * 2] * g[i * 2 + 1] % P;
    g.resize(m);
    idft(f), idft(g);
    for (int i = 0, j = n & 1; i < len; i++, j += 2) f[i] = f[j];
    f.resize(len), g.resize(len);
  }
  return f[0];
}
}  // namespace Polynomial
```

## 分治FFT

> O（nlog<sup>2</sup>n)

$$
\prod_{i=1}^{n}(a_i\cdot x+1)
$$

```c++
Poly solve(int L,int R){
	if(L==R) 
		return {a[L],1};
	int mid=L+R>>1;
	return solve(L,mid)*solve(mid+1,R);
}
```

```c++
//罗老师板子
vi solve(int l,int r){
	if(l==r) 
		return {c[l],b[l]};
	int mid=l+r>>1;
	return fft::multiply_mod(solve(l,mid),solve(mid+1,r),mod);	//需要把模板里vector传参的引用删了
}
```

## 字符串匹配

检查每个字符，模式串倒叙与匹配串正序的生成函数乘积累加（其实就是卷积累加），最终的C<sub>i>m-1</sub>=m则匹配成功

```c++
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define forn(i,t) for(int i=1;i<=t;i++)
#define forr(i,t) for(int i=t;i>=1;i--)
#define IOFast() ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;
namespace fft
{
    struct num
    {
        double x,y;
        num() {x=y=0;}
        num(double x,double y):x(x),y(y){}
    };
    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}
    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}
    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    inline num conj(num a) {return num(a.x,-a.y);}

    int base=1;
    vector<num> roots={{0,0},{1,0}};
    vector<int> rev={0,1};
    const double PI=acosl(-1.0);

    void ensure_base(int nbase)
    {
        if(nbase<=base) return;
        rev.resize(1<<nbase);
        for(int i=0;i<(1<<nbase);i++)
            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));
        roots.resize(1<<nbase);
        while(base<nbase)
        {
            double angle=2*PI/(1<<(base+1));
            for(int i=1<<(base-1);i<(1<<base);i++)
            {
                roots[i<<1]=roots[i];
                double angle_i=angle*(2*i+1-(1<<base));
                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));
            }
            base++;
        }
    }

    void fft(vector<num> &a,int n=-1)
    {
        if(n==-1) n=a.size();
        assert((n&(n-1))==0);
        int zeros=__builtin_ctz(n);
        ensure_base(zeros);
        int shift=base-zeros;
        for(int i=0;i<n;i++)
            if(i<(rev[i]>>shift))
                swap(a[i],a[rev[i]>>shift]);
        for(int k=1;k<n;k<<=1)
        {
            for(int i=0;i<n;i+=2*k)
            {
                for(int j=0;j<k;j++)
                {
                    num z=a[i+j+k]*roots[j+k];
                    a[i+j+k]=a[i+j]-z;
                    a[i+j]=a[i+j]+z;
                }
            }
        }
    }

    vector<num> fa,fb;
    
    vector<int> multiply(vector<int> &a, vector<int> &b)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<sz;i++)
        {
            int x=(i<(int)a.size()?a[i]:0);
            int y=(i<(int)b.size()?b[i]:0);
            fa[i]=num(x,y);
        }
        fft(fa,sz);
        num r(0,-0.25/sz);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;
            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;
            fa[i]=z;
        }
        fft(fa,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;
        return res;
    }

    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<(int)a.size();i++)
        {
            int x=(a[i]%m+m)%m;
            fa[i]=num(x&((1<<15)-1),x>>15);
        }
        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});
        fft(fa,sz);
        if(sz>(int)fb.size()) fb.resize(sz);
        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());
        else
        {
            for(int i=0;i<(int)b.size();i++)
            {
                int x=(b[i]%m+m)%m;
                fb[i]=num(x&((1<<15)-1),x>>15);
            }
            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});
            fft(fb,sz);
        }
        double ratio=0.25/sz;
        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num a1=(fa[i]+conj(fa[j]));
            num a2=(fa[i]-conj(fa[j]))*r2;
            num b1=(fb[i]+conj(fb[j]))*r3;
            num b2=(fb[i]-conj(fb[j]))*r4;
            if(i!=j)
            {
                num c1=(fa[j]+conj(fa[i]));
                num c2=(fa[j]-conj(fa[i]))*r2;
                num d1=(fb[j]+conj(fb[i]))*r3;
                num d2=(fb[j]-conj(fb[i]))*r4;
                fa[i]=c1*d1+c2*d2*r5;
                fb[i]=c1*d2+c2*d1;
            }
            fa[j]=a1*b1+a2*b2*r5;
            fb[j]=a1*b2+a2*b1;
        }
        fft(fa,sz);fft(fb,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++)
        {
            ll aa=fa[i].x+0.5;
            ll bb=fb[i].x+0.5;
            ll cc=fa[i].y+0.5;
            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;
        }
        return res;
    }
    vector<int> square_mod(vector<int> &a,int m)
    {
        return multiply_mod(a,a,m,1);
    }
};
int n,m;
string s,t;
void init(){
    cin>>n>>m>>s>>t;
    reverse(t.begin(),t.end());
}
void solve(){
    int bonus=0;
    for(auto i:t)
        if(i=='*')
            bonus++;
    vector<int> res(m+n-1,0);
    for(int i=0;i<=9;i++)
    {
        vector<int> v1(n,0),v2(m,0);
        for(int j=0;j<n;j++)
            if(s[j]=='*'||s[j]=='0'+i)
                v1[j]=1;
        for(int j=0;j<m;j++)
            if(t[j]=='0'+i)
                v2[j]=1;
        vector<int> v3=fft::multiply(v1,v2);    
        int len=v3.size();
        for(int i=0;i<len;i++)
            res[i]+=v3[i];
    }
    vector<int> cnt(m+1,0),sum(m+1,0);
    for(int i=m-1;i<=n-1;i++)
        cnt[m-bonus-res[i]]++;
    sum[0]=cnt[0];
    for(int i=1;i<=m;i++)
        sum[i]=sum[i-1]+cnt[i];
    for(int i=0;i<=m;i++)
        cout<<sum[i]<<'\n';
}
signed main(){
    IOFast();
    int TT;
    cin>>TT;
    while(TT--)
    {
        init();
        solve();
    }
}
```

# DFT/IDFT

```c++
//f=1为DFT，f=0位IDFT
void NTT(int*a,int f){
	for(int i=1;i<lim;++i)if(i<rev[i])std::swap(a[i],a[rev[i]]);
	for(int i=1;i<lim;i<<=1){
		const int gi=pow(f?3:g3,(md-1)/(i<<1));
		for(int j=0;j<lim;j+=i<<1)
		for(int k=0,g=1;k<i;++k,g=(LL)g*gi%md){
			const int x=a[j+k],y=a[j+k+i]*(LL)g%md;
			upd(a[j+k]+=y-md),upd(a[j+k+i]=x-y);
		}
	}
	if(!f){
		const LL iv=pow(lim,md-2);
		for(int i=0;i<lim;++i)a[i]=a[i]*iv%md;
	}
}
```

# 快速沃尔什变换（FWT）

$$
C_k=\sum_{i \oplus j=k} A_i B_j
$$

```C++
int N=1<<18;//空间可以多开，但是N得正正好好等于数组a的容量
/// O(n*2^(n))
//模意义下
void fwt_or(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[i+j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[i+j+k]=(a[i+j+k]+mod-a[j+k])%mod;
}
/*
fwt_or(a,1);
fwt_or(b,1);
for(int i=0;i<n;++i)
    c[i]=a[i]*b[i]%mod;
fwt_or(c,-1);
*/
void fwt_and(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[j+k]=(a[j+k]+a[i+j+k])%mod;
                else a[j+k]=(a[j+k]+mod-a[i+j+k])%mod;
}
/*
fwt_and(a,1);
fwt_and(b,1);
for(int i=0;i<n;++i)
    c[i]=a[i]*b[i]%mod;
fwt_and(c,-1);
*/
//inv2为2的逆元  inv2=mod/2+1;
void fwt_xor(int *a,int opt)	
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
            {
                int X=a[j+k],Y=a[i+j+k];
                a[j+k]=(X+Y)%mod;a[i+j+k]=(X+mod-Y)%mod;
                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2%mod,a[i+j+k]=1ll*a[i+j+k]*inv2%mod;
            }
}
/*
fwt_xor(a,1);
fwt_xor(b,1);
for(int i=0;i<n;++i)
    c[i]=(a[i]*b[i]+mod)%mod;
fwt_xor(c,-1);
*/
//or卷积
void fwt(ll *P,int opt)
{
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
				P[k+p]+=P[k]*opt;
}
//and卷积
void fwt(ll *P,int opt)
{
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
				P[k]+=P[k+p]*opt;
}
//异或卷积
void fwt(ll *P,int opt)
{
	for(int i=2;i<=N;i<<=1)
		for(int p=i>>1,j=0;j<N;j+=i)
			for(int k=j;k<j+p;++k)
			{
				ll x=P[k],y=P[k+p];
				P[k]=(x+y);P[k+p]=x-y;
				if(opt==-1) P[k]=P[k]/2,P[k+p]=P[k+p]/2;
			}
}
///F[x]=sigma A_i[x&i=i] subset of x  超集只需判定条件改成==0
for(int i=0;i<20;++i) for(int j=0;j<(1<<20);++j) if(j&(1<<i)) f[j]+=f[j^(1<<i)];

//fmt SOSdp 子集卷积
const int maxn=1e6+7,inf=0x3f3f3f3f,mod=1e9+9;
int bc[1<<20],n,len;
int a[21][1<<20],b[21][1<<20],c[21][1<<20];
void fmt(int *f,int op) {
    for(int i=0;i<n;++i)
        for(int j=0;j<len;++j)
            if(j&(1<<i))
            {
                if(op==1) f[j]=(f[j]+f[j^(1<<i)])%mod;
                else f[j]=(f[j]-f[j^(1<<i)]+mod)%mod;
            }
}
int main() {
    cin>>n;
    len=1<<n;
    for(int i=1;i<len;++i) bc[i]=bc[i-(i&-i)]+1;
    for(int i=0;i<len;++i) cin>>a[bc[i]][i];
    for(int i=0;i<len;++i) cin>>b[bc[i]][i];
    for(int i=0;i<=n;++i) fmt(a[i],1),fmt(b[i],1);
    for(int i=0;i<=n;++i) for(int j=0;j<=i;++j) for(int s=0;s<len;++s) c[i][s]=(c[i][s]+1ll*a[j][s]*b[i-j][s]%mod)%mod;
    for(int i=0;i<=n;++i) fmt(c[i],-1);
    for(int i=0;i<len;++i) cout<<c[bc[i]][i]<<" ";
    cout<<'\n';
    return 0;
}

//任意多个子集的卷积 倍增处理
const int mod = 998244353;
int Len = 1 << 21, Base = 21;
inline void fmt_or(vector<int>& f,int op=1,int base=Base)//子集和
vector<int> pc;
void get_top(int sz) {
    pc.resize(sz, 0);
    for (int i = 1; i < sz; ++i) pc[i] = pc[i >> 1] + (i & 1);
}
vector<int> subset_conv(vector<int> A, vector<int> B, int base) {
    int len = 1 << base;
    vector<int> H(len);
    vector<vector<int> > siga(base + 1, vector<int>(len, 0)), sigb = siga, sigh = siga;
    for (int S = 0; S < len; ++S) siga[pc[S]][S] = A[S], sigb[pc[S]][S] = B[S];
    for (int i = 0; i <= base; ++i) {
        fmt_or(siga[i], 1, base);
        fmt_or(sigb[i], 1, base);
        for (int j = 0; j <= i; ++j)
            for (int S = 0; S < len; ++S) sigh[i][S] = mo(sigh[i][S] + muln(siga[j][S], sigb[i - j][S]));
        fmt_or(sigh[i], -1, base);
    }
    for (int S = 0; S < len; ++S) H[S] = sigh[pc[S]][S];
    return H;
}
vector<int> conv(const vector<int>& p) {
    //A[n][S] = \sum_{ T \in S-\{n\} } A[pc(T)][T] \cdot p[n][S-T]
    get_top(Len);
    vector<int> ret(Len, 0);
    ret[0] = 1;
    for (int n = 0; n < Base; ++n) {
        int ful = 1 << n;
        auto A = vector<int>(ret.begin(), ret.begin() + ful);
        auto B = vector<int>(p.begin() + ful, p.begin() + ful * 2);
        A = subset_conv(A, B, n);
        for (int i = ful; i < ful * 2; ++i) ret[i] = A[i - ful];
    }
    return ret;
}

int main() {
    int n, q, prob, b;
    vector<int> p(Len, 0);
    scanf("%d",&n);
    for(int i=1;i<=n;++i) {
        scanf("%d%d",&prob,&b);
        p[b] = mo(p[b] + prob);
    }
    auto ans = conv(p);
    scanf("%d",&q);
    while (q--) {
        scanf("%d",&b);
        printf("%d\n",ans[b]);
    }
    return 0;
}
```

# 单位根

模长为1的复数
$$
z=cos\theta+isin\theta\\
w_{n}^{k}=cos\cfrac{k}{n}2\pi+isin\cfrac{k}{n}2\pi
$$

性质1:
$$
w_{n}^{k}=w_{2n}^{2k}
$$
性质2:
$$
w_{n}^{k+\cfrac{n}{2}}=-w_{n}^{k}
$$
性质3:
$$
w_{n}^{0}=w_{n}^{n}=1,w_{n}^{\cfrac{n}{2}}=-1
$$
性质4:
$$
w_{n}^{p}\cross w_{n}^{q}=w_{n}^{p+q}
$$

## 与原根的关系

对于质数$p=qn+1(q=2^{m})$，原根g满足$g^{qn}\equiv 1(mod\ p)$，将$g_{n}=g^{q}(mod\ p)$看作$w_{n}$的等价，则其满足相似的性质，比如$g_{n}^{n}\equiv 1(mod\ p)$，$g_{n}^{n/2}\equiv -1(mod\ p)$

一般

$p=998244353=7\cross17\cross2^{23}+1,g=3$

$p=1004535809=479\cross2^{21}+1,g=3$

$w_{n}^{1}=g^{\cfrac{p-1}{n}}(n|(p-1))$

## 单位根反演

$$
[n|a]=\cfrac{1}{n}\sum_{k=0}^{n-1}w_{n}^{ak}\\
[a=b(mod\ n)]=[a-b=0(mod\ n)]=\cfrac{1}{n}\sum_{i=0}^{n-1}w_{n}^{(a-b)k}=\cfrac{1}{n}\sum_{i=0}^{n-1}w_{n}^{ak}w_{n}^{-bk}
$$



# 线性基

>  线性基三大性质

原序列里面的任意一个数都可以由线性基里面的一些数异或得到
线性基里面的任意一些数异或起来都不能得到 0 
线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的

线性基可以O(N^2)求01矩阵的秩

```c++
int p[63]; 
inline void insert(ll x){
	for(int i = 62; i + 1; i -- ){
		if(!(x >> i))
			continue; 
		if(!p[i]){
			p[i] = x; 
			break; 
		}
		x ^= p[i]; 
	}
}

//最大
ll mx(){
	ll ans = 0; 
	for(int i = 62; i >= 0;  -- i){
		if((ans ^ p[i]) > ans) ans ^= p[i]; 
	}
	return ans; 
}

//最小
//注意，这里指的是用线性基内的元素能异或出的最小值。

//显然就是最小的 d[i] 了，因为最小的 d[i] 无论异或谁都会变大。

//如果是求整个序列能异或出的最小值而不是这个序列的线性基能异或出的最小值的话，要另外看一看有没有元素不能插入线性基，如果有，那么最小值就是 0，否则依然是最小的 d[i]。

//第k大
void work()//处理线性基
{
	for(int i=1;i<=60;i++)
	for(int j=1;j<=i;j++)
	if(d[i]&(1ll<<(j-1)))d[i]^=d[j-1];
}
ll k_th(ll k)
{
	if(k==1&&tot<n)return 0;//特判一下，假如k=1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度
	if(tot<n)k--;//类似上面，去掉0的情况，因为线性基中只能异或出不为0的解
	work();
	ll ans=0;
	for(int i=0;i<=60;i++)
	if(d[i]!=0)
	{
		if(k%2==1)ans^=d[i];
		k/=2;
	}
}
```

> 前缀线性基

```c++
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define int ll
#define forn(i, n) for (int i = 1; i <= n; ++i)
#define forr(i, n) for (int i = n; i >= 1; --i)
#define IOFast() ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)

const int maxn = 4e5 + 10; 
int a[maxn][60]; 
int pos[maxn][60]; 
void insert(int r, int x){
	int p = r; 
	for(int i = 60; i >= 0;  -- i){
		if((x >> i) & 1)  {
			if(!a[r][i]){
				a[r][i] = x; 
				pos[r][i] = p; 
				return; 
			}
			if(pos[r][i] < p) swap(pos[r][i], p), swap(x, a[r][i]); 
			x ^= a[r][i]; 
		}
	}
}

void solve(){
	int n, q; 
	cin >> n >> q; 
	forn(i, n){
		int num; 
		cin >> num; 
		for(int j=0;j<=60;++j)
			pos[i][j]=pos[i-1][j],a[i][j]=a[i-1][j];
		insert(i, num); 
	}
	while(q -- ){
		int L, r, x; 
		cin >> L >> r >> x; 
		for(int i = 60; i >= 0;  -- i){
			if((x >> i) & 1){
				if(pos[r][i] >= L){
					x ^= a[r][i]; 
				}
			}
		}
		if(x) cout << "No\n"; 
		else cout << "Yes\n"; 
	}
}
signed main(){
	IOFast(); 
	solve(); 
}
```

# 二分等比数列求和（存在逆元无意义时使用）

当n为奇数时,例如n=5

则1+p+p^2+p^3+p^4+p^5=(1+p+p^2)+p^3\*(1+p+p^2)=(1+p+p^2)*(1+p^3)

可以发现1+p+p^2+...p^n=(1+p+p^2+...+p^(k + 1)/2 - 1)]\*(1 + p^(k + 1)/2)

 

当n为偶数时，例如n=4

则1+p+p^2+p^3+p^4=(1+p)+p^3\*(1+p)+p^2=(1+p)*(1+p^3)+p^2

可以发现1+p+p^2+...p^n=(1+p+p^2+...+p^(k/2-1))\*(1+p^(k/2+1))+p^(k/2)

> O(logn)分治

```c++
//计算1 + p + p^2 + p^3 +.....+p^k
int getsum(int p,int k)
{
  if(k==0)	return 1;
  if(k&1)
    return ((getsum(p,(k+1)/2-1)%mod)*((1ll+qpow(p,(k+1)/2))%mod))%mod;
  else return ((getsum(p,k/2-1)%mod)*((1+qpow(p,k/2+1))%mod)+qpow(p,k/2)%mod)%mod;
}
```

# 组合数学

## 组合数取模与lucas定理

```c++
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
#define ll long long
const int mod=1e9+7;
ll quick_mod(ll a,ll b){ ///快速幂，a^b(a的b次方)
    ll ans=1;
    while(b){
        if(b&1){
           ans=(ans*a)%mod;
        }
        b>>=1;
        a=(a*a)%mod;
    }
    return ans;
}
ll Comb(ll n,ll m){ //求组合数C(n,m)，容易爆long long，看情况使用高精
	//应n>m
    ll a=1,b=1; //a/b;
    if(m==0)  return 1;
    if(n<m) return 0;	//应n>m
    if(n-m<m) m=n-m;
    ll sum=1;
    for(int i=1;i<=m;i++){
        a=a*(n+i-m)%mod;	//若为不取模版本，可优化为乘完立马除，减小爆long long的概率
        b=b*i%mod;
        
    }
    sum=(a*quick_mod(b,mod-2))%mod;
      return sum;
}
ll lucas(ll a,ll b){	//应a>b
    ll ans=1;
    while(a&&b){
        ans=(ans*Comb(a%mod,b%mod))%mod;
        a/=mod;
        b/=mod;
    }
    return ans;
}
```
### 生成组合数

```c++
int Fac[MAXL*2],Inv[MAXL*2];	//Fac为阶乘，Inv为阶乘逆元

void Prepare(int n)	//n为上界
{
	Fac[0] = 1;
	for (int i = 1; i <= n; i ++)
		Fac[i] = 1LL * Fac[i - 1] * i % MOD;
	Inv[0] = Inv[1] = 1;
	for (int i = 2; i <= n; i ++)
		Inv[i] = MOD - 1LL * (MOD / i) * Inv[MOD % i] % MOD;
	for (int i = 2; i <= n; i ++)
		Inv[i] = 1LL * Inv[i - 1] * Inv[i] % MOD;
}

inline int C(int u, int v)	//u>=v
{
	if (u < 0 || v < 0 || u < v)
		return 0;
	return 1LL * Fac[u] * Inv[v] % MOD * Inv[u - v] % MOD;
}
```

## 生成排列数

```c++
int Fac[MAXL*2],Inv[MAXL*2];

void Prepare(int n)	//n为上界
{
	Fac[0] = 1;
	for (int i = 1; i <= n; i ++)
		Fac[i] = 1LL * Fac[i - 1] * i % MOD;
	Inv[0] = Inv[1] = 1;
	for (int i = 2; i <= n; i ++)
		Inv[i] = MOD - 1LL * (MOD / i) * Inv[MOD % i] % MOD;
	for (int i = 2; i <= n; i ++)
		Inv[i] = 1LL * Inv[i - 1] * Inv[i] % MOD;
}

inline int P(int u, int v)	//u>=v
{
	if (u < 0 || v < 0 || u < v)
		return 0;
	return 1LL * Fac[u]  * Inv[u - v] % MOD;
}
```

## 卡特兰数

数列的前几项为：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862，...

1. 有一个长度为2n的01序列，其中1,0各n个，要求对于任意的整数k∈[1,2n]，数列的前k个数中，1的个数不少于0。

2. n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列。

3. n 对括号，则有多少种 “括号匹配” 的括号序列(左括号看成+1，右括号看成-1)
4. n + 1 个叶子节点能够构成多少种形状不同的满二叉树（由于每个非叶子节点都有两个左右子节点，所有它必然会先向左扩展，再向右扩展。总体下来，左右扩展将会形成匹配，即变成进出栈的题型。）

对于样例2的详细说明：

我们将进栈表示为 +1，出栈表示为 -1，则 1 3 2 的出栈序列可以表示为：+1 -1 +1 +1 -1 -1。

根据栈本身的特点，每次出栈的时候，必定之前有元素入栈，即对于每个 -1 前面都有一个 +1 相对应。因此，出栈序列的 **所有前缀和** 必然大于等于 0，并且 +1 的数量 **等于** -1 的数量。

接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。

如果将 **第一个** 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1个 -1 的序列。

如何证明这两种序列是一一对应的？

假设非法序列为 A，对应的序列为 B。每个 A 只有一个"**第一个前缀和小于 0 的前缀**"，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到"**第一个前缀和大于 0 的前缀**"，显然 B 也只能产生一个 A。

每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为
$$
C_{2n}^{n+1}
$$
相当于在长度为 2n 的序列中找到`n + 1`个位置存放 +1。相应的，非法序列的数量也就等于
$$
C_{2n}^{n+1}
$$
出栈序列的总数量共有
$$
C_{2n}^{n}
$$
因此，合法的出栈序列的数量为
$$
C_{2n}^{n}-C_{2n}^{n+1}=\cfrac{C_{2n}^{n}}{n+1}
$$
此时我们就得到了卡特兰数的通项
$$
\cfrac{C_{2n}^{n}}{n+1}
$$

$$
P(n)=\sum_{k=1}^{n-1}P(n-k)P(k),P(1)=1也是卡特兰数
$$

## 第二类斯特林数

S(n,k)表示n个两两不同的元素划分为k个互不区分的非空集合的方案数

>  递推式

$$
\begin{Bmatrix}n\\m\end{Bmatrix}
$$

$$
S(n,k)=S(n-1)(k-1)+k\cdot S(n-1,k)\\
S(n,0)=[\ n=0\ ]
$$

组合意义：插入一个新元素时

1. 放入单独一个子集，有S(n-1,k-1)种方案；
2. 放入一个现有子集，有k*S(n-1,k-1)种方案。

```c++
void init(){
    S[0][0]=1;
    for(int i=1;i<maxn;++i)
        for(int j=1;j<=i;++j){
            S[i][j]=(S[i-1][j-1]+j*S[i-1][j]%mod)%mod;
        }
}
```

>  通项公式

$$
S(n,m)=\sum_{i=0}^{m}\cfrac{(-1)^{m-i}i^{n}}{i!(m-i)!}
$$

计算同一行第二类斯特林数（同一行指n相同的一系列不同S(n,i)），其值为
$$
\sum_{m=0}^{n}\sum_{i=0}^{m}\cfrac{(-1)^{m-i}i^{n}}{i!(m-i)!}
$$
可以将式子拆分为
$$
\sum_{m=0}^{n}\sum_{i=0}^{m}\cfrac{(-1)^{m-i}}{(m-i)!}\cdot \cfrac{i^{n}}{i!}
$$
可以构造两个多项式，
$$
\sum_{i=0}^{n}\cfrac{(-1)^{i}}{i!}x^{i}\\
\sum_{i=0}^{n}\cfrac{i^{n}}{i!}x^{i}
$$
对它们做卷积时间复杂度可优化至O(nlogn)

```c++
int main() {
  scanf("%d", &n);
  fact[0] = 1;
  for (int i = 1; i <= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;
  exgcd(fact[n], mod, ifact[n], ifact[0]),
      ifact[n] = (ifact[n] % mod + mod) % mod;
  for (int i = n - 1; i >= 0; --i) ifact[i] = (ll)ifact[i + 1] * (i + 1) % mod;
  poly f(n + 1), g(n + 1);
  for (int i = 0; i <= n; ++i)
    g[i] = (i & 1 ? mod - 1ll : 1ll) * ifact[i] % mod,
    f[i] = (ll)qpow(i, n) * ifact[i] % mod;
  f *= g, f.resize(n + 1);
  for (int i = 0; i <= n; ++i) printf("%d ", f[i]);//答案为f[n]
  return 0;
}
```

## 第一类斯特林数

表示将n个两两不同的元素，划分为k个互不区分的非空轮换的方案数。
$$
\begin{bmatrix}n\\ m \end{bmatrix}
$$
一个轮换就是一个首尾相接的环形排列。我们可以写出一个轮换 [A,B,C,D=[B,C,D,A]=[C,D,A,B]=[D,A,B,C]，即两个可以通过旋转而互相得到的轮换是等价的。注意，我们不认为两个可以通过翻转而相互得到的轮换等价，即[A,B,C,D]!=[D,C,B,A]

> 递推式

$$
s(n,k)=s(n-1,k-1)+(n-1)\cdot s(n-1,k)\\
s(n,0)=[\ n=0\ ]
$$

组合意义：

1. 新元素置于一个单独的轮换，共s(n-1,k-1)种方案；
2. 新元素插入任何一个现有的轮换，共有(n-1)*s(n-1,k)种方案。

无实用通项公式

```c++
void init(){
    S[0][0]=1;
    for(int i=1;i<maxn;++i)
        for(int j=1;j<=i;++j){
            S[i][j]=(S[i-1][j-1]+(i-1)*S[i-1][j]%mod)%mod;
        }
}
```

## 贝尔数

$B_{n}$是基数为n的集合的划分方法的数目，集合S的一个划分定义为S的两两不相交的非空子集的族，它们的并是S。

递推公式：
$$
B_{n+1}=\sum_{k=0}^{n}C_{n}^{k}B_{k}
$$
另外有
$$
B_{n}=\sum_{k=0}^{n}S(n,k)
$$

## 康托展开

拿52413举例子：

1、首先看第一个数 5，不管第一位是什么数，后面都有四位数，那么这四位数全排列的方式有 4！种，而如果第一位是 1 或 2 或 3 或 4 都会比5开头的字典序要小，所以可以令1，2，3，4分别作为开头，这样的话就会有 4 * 4！种排法要比  52413这种排法的字典序要小。

那么第一个数是1，2，3，4时候的字典序的个数数完了是 4 * 4！ 种，且这些字典序都要比52413的字典序要小。

还有其他的排列方式比52413的字典序要小的吗？

2、那么就可以固定第一位5，找下一位2，这时5已经用过了，所以从剩下的 1，2，3，4 里挑选比2小的数，一共1个，后面还剩三位，也就是3！种排列方式，那么这时候比 52413 字典序要小的又有  1 * 3！种，也就是当5在第一位，1在第二位的时候。

3、再看第三位4，这时5，2都用了，所以从剩下的 1，3，4三个数中找比4小的数的个数，有两个比4小原理同上，所以这时候也可以有 2 * 2!种排列方式的字典序小于 52413

4、再看第四位1，这时候会有 0 * 1！种

5、再看第五位3，这时候会有0 * 0！种

```c++
/***** 这里以字符串进行展示  字符串可泛化性好 ******/
 
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
 
/*******打出1-n的阶乘表*******/
int f[20];
void jie_cheng(int n)
{
    f[0] = f[1] = 1; // 0的阶乘为1
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}
 
/**************康托展开****************/
string str;
int kangtuo()
{
    int ans = 1;  //注意，因为 12345 是算作0开始计算的，最后结果要把12345看作是第一个
    int len = str.length();
    for(int i = 0; i < len; i++){
        int tmp = 0;//用来计数的
 
        for(int j = i + 1; j < len; j++){
            if(str[i] > str[j]) tmp++;
            //计算str[i]是第几大的数，或者说计算有几个比他小的数
        }
 
        ans += tmp * f[len - i - 1];
    }
    return ans;
}
 
int main()
{
    jie_cheng(10);
    string str = "52413";
    cout<<kangtuo()<<endl;
}
```

> 逆康托展开

如果初始序列是12345（第一个），让你求第107个序列是什么。（按字典序递增）

这样计算：

先把107减1，因为康托展开里的初始序列编号为0
然后计算下后缀积：
  1      2      3    4    5
  5！  4！  3！ 2！1！ 0！
120   24     6    2    1     1

106 /  4! = 4 ······ 10 有4个比它小的所以因该是5   从（1，2，3，4，5）里选
10   /  3!  = 1 ······ 4  有1个比它小的所以因该是2   从（1， 2， 3， 4）里选
 4    /  2!  = 2 ······ 0  有2个比它小的所以因该是4   从（1， 3， 4）里选
 0    /  1!  = 0 ······ 0  有0个比它小的所以因该是1   从（1，3）里选
 0    /  0!  = 0 ······ 0  有0个比它小的所以因该是3   从（3）里选

所以编号107的是 52413

```c++
/***** 这里以字符串进行展示  字符串可泛化性好 ******/
 
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
 
/*******打出1-n的阶乘表*******/
int f[20];
int x, num;
 
void jie_cheng(int n)
{
    f[0] = f[1] = 1; // 0的阶乘为1
    for(int i = 2; i <= n; i++) f[i] = f[i - 1] * i;
}
 
/**************康托逆展开**************/
 
vector<char> vec; //存需要排列的字符
void rev_kangtuo(int k) //输出序号为 k 的字符序列
{
    int n = vec.size(), len = 0;
    string ans = "";
    k--; // 算的时候是按 12345 是第0位
    for(int i = 1; i <= n; i++){
        int t = k / f[n - i]; // 第 i 位需要 第 t + 1 大的数
        k %= f[n - i];        //剩下的几位需要提供的排列数
        ans += vec[t] ; //  vec[t] 就是第 t + 1 大的数
        vec.erase(vec.begin() + t); 
//用过就删了，不用vector用暴力也可以，就是说枚举，然后一个一个的比较大小，并记录有几个没用过的字符且字典序比它小
    }
    cout << ans << '\n';
}
 
/***************************************/
// 假设展开后不超过10位
int main()
{
    jie_cheng(10); // 预处里好阶乘
    scanf("%d", &x); // 输入需要逆展开的数字
    /************康托逆展开***********/
    for(int i = 1; i <= 10; i++)
    {
    	if(x / f[i] == 0) // 求出 x 逆展开所需的最小的位数，方便下面的初始化
    	{
    		num = i;
    		break;
    	}
    }
    for(int i = 1; i <= num; i++) vec.push_back(i + '0'); //输入的位数只要不小于num就可以
    rev_kangtuo(x);
}
```

> O(n^2)

```c++
namespace Cantor {
    const int N=100;
    int fac[N];
    void init() {
        fac[0]=1;
        for(int i=1; i<N; ++i)fac[i]=fac[i-1]*i;
    }
    int encode(int* a,int n) {
        int ret=0;
        for(int i=n-1; i>=0; --i) {
            int cnt=0;
            for(int j=i+1; j<n; ++j)if(a[j]<a[i])++cnt;
            ret+=cnt*fac[n-1-i];
        }
        return ret;
    }
    vector<int> decode(int x,int n) {
        vector<int> ret;
        vector<int> v;
        for(int i=1; i<=n; ++i)v.push_back(i);
        for(int i=n-1; i>=0; --i) {
            ret.push_back(v[x/fac[i]]);
            v.erase(v.begin()+x/fac[i]);
            x%=fac[i];
        }
        return ret;
    }
}
```

> 树状数组辅助O(nlogn)

```c++
namespace Cantor {
    const int N=100;
    int fac[N],c[N],n,m;
    void init() {
        fac[0]=1;
        for(int i=1; i<N; ++i)fac[i]=fac[i-1]*i;
    }
    void setn(int _n) {
        n=_n;
        m=1;
        while(m<=n)m<<=1;
        for(int i=0; i<m; ++i)c[i]=0;
    }
    int lowbit(int x) {
        return x&-x;
    }
    void add(int u,int x) {
        while(u<m) {
            c[u]+=x;
            u+=lowbit(u);
        }
    }
    int rnk(int u) {
        int ret=0;
        while(u) {
            ret+=c[u];
            u-=lowbit(u);
        }
        return ret;
    }
    int kth(int k) {
        int ret=0;
        for(int i=m>>1; i; i>>=1) {
            if(c[ret+i]<k) {
                ret+=i;
                k-=c[ret];
            }
        }
        return ret+1;
    }
    int encode(int* a,int _n) {
        setn(_n);
        int ret=0;
        for(int i=n-1; i>=0; --i) {
            ret+=rnk(a[i])*fac[n-1-i];
            add(a[i],1);
        }
        return ret;
    }
    vector<int> decode(int x,int _n) {
        setn(_n);
        vector<int> ret;
        for(int i=1; i<=n; ++i)add(i,1);
        for(int i=n-1; i>=0; --i) {
            int t=kth(x/fac[i]+1);
            ret.push_back(t);
            add(t,-1);
            x%=fac[i];
        }
        return ret;
    }
}
```

> 测试代码

```c++
int main() {
    Cantor::init();
    int a[]= {1,2,3,4};
    do {
        printf("%d\n",Cantor::encode(a,4));
    } while(next_permutation(a,a+4));
    for(int i=0; i<24; ++i) {
        vector<int> v=Cantor::decode(i,4);
        for(int i=0; i<v.size(); ++i)printf("%d%c",v[i]," \n"[i==v.size()-1]);
    }
    return 0;
}
```

# 矩阵类

## 矩阵快速幂

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
struct matrix{
    vector<vector<int> > num;
    matrix(){}
    matrix(int n){
        num.resize(n);
        for(int i=0;i<n;++i)
        num[i].resize(n);
    }
    matrix(int n,int m){
        num.resize(n);
        for(int i=0;i<n;++i)
        num[i].resize(m);
    }
    template<int n,int m>
    matrix(const int (&cpy)[n][m]){
        num.resize(n);
        for(int i=0;i<n;++i)
        num[i].resize(m);
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                num[i][j]=cpy[i][j];
    }
    matrix(const vector<vector<int> > & cpy){
        int n=cpy.size();
        int m=cpy[0].size();
        num.resize(n);
        for(int i=0;i<n;++i)
        num[i].resize(m);
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                num[i][j]=cpy[i][j];
    }
    matrix(const matrix & cpy){
        int n=cpy.num.size();
        int m=cpy.num[0].size();
        num.resize(n);
        for(int i=0;i<n;++i)
            num[i].resize(m);
        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                num[i][j]=cpy.num[i][j];
    }
    friend ostream& operator <<(ostream& out,matrix show){
        int n=show.num.size();
        int m=show.num[0].size();
        for(int i=0;i<n;i++)
            for(int j=0;j<m;++j)
                cout<<show.num[i][j]<<" \n"[j==m-1];
        return out;
    }
    matrix operator *(const matrix &multi){
        int a=num.size();
        int b=num[0].size();
        int c=multi.num[0].size();
        matrix res(a,c);
        for(int i=0;i<a;++i)
            for(int j=0;j<c;++j)
                    for(int k=0;k<b;++k)
            (res.num[i][j]+=(num[i][k]*multi.num[k][j])%mod)%=mod;
        return res;
    }
};
matrix qpow(matrix a,int r)
{
    matrix res;
    int n=a.num.size();
    res.num.resize(n);
    for(int i=0;i<n;++i)
        res.num[i].resize(n);
    for(int i=0;i<n;++i)
        res.num[i][i]=1;
    matrix base(a);
    while(r){
        if(r%2==1)res=res*base;
        base=base*base;
        r>>=1;
    }
    return res;
}
signed main(){
    int n;
    cin>>n;
    int v[2][2]={{1,1},{1,0}};
    int a[1][2]={{1,1}};
    matrix m(v),A(a);
    if(n==1){
        cout<<"1\n";
        return 0;
    }
    matrix Pow=qpow(m,n-2);
    cout<<(A*qpow(m,n-2)).num[0][0];
}
```

## 高斯消元

> O(n<sup>3</sup>)

```c++
const double eps=1e-8;
const int N=1e4+10;
double a[N][N];
int n;	//n一定要初始化
// a[N][N]是增广矩阵
// n为增广矩阵行数; a[i][n]为线性方程组的解
// 最终为 
// 1 0 0 x1
// 0 1 0 x2
// 0 0 1 x3
//	a[0][0]x1+a[0][1]x2+...+a[0][n-1]xn=a[0][n]
//	a[1][0]x1+a[1][1]x2+...+a[1][n-1]xn=a[1][n]
//	...
//	a[n-1][0]x1+a[n-1][1]x2+...+a[n-1][n-1]xn=a[n-1][n]
int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )   // 找到绝对值最大的行
        if (fabs(a[i][c]) > fabs(a[t][c]))
            t = i;
        
        if (fabs(a[t][c]) < eps) continue;
        
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )       // 用当前行将下面所有的列消成0
        if (fabs(a[i][c]) > eps)
            for (int j = n; j >= c; j -- )
                a[i][j] -= a[r][j] * a[i][c];
        r ++ ;
    }

    if (r < n)
    {
        for (int i = r; i < n; i ++ )
        if (fabs(a[i][n]) > eps)
        return 2; // 无解
        return 1; // 有无穷多组解
    }

    for (int i = n - 1; i >= 0; i -- )
    for (int j = i + 1; j < n; j ++ )
        a[i][n] -= a[i][j] * a[j][n];
    
    return 0; // 有唯一解
}
signed main()
{
    cin>>n;
    for(int i=0;i<n;i++)
            for(int j=0;j<n+1;j++)
                    cin>>a[i][j];
    if(gauss())cout<<"No Solution\n";
    else {
        for(int i=0;i<n;i++)
            cout<<fixed<<setprecision(2)<<a[i][n]<<'\n';
    }
}
```

## 高斯-约旦消元

>  O(n<sup>3</sup>)

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e2+10;
const double eps=1e-6;
int n;
double a[maxn][maxn];
//	a[1][1]x1+a[1][2]x2+...+a[1][n]xn=a[1][n+1]
//	a[2][1]x1+a[2][2]x2+...+a[2][n]xn=a[2][n+1]
//	...
//	a[n][1]x1+a[n][2]x2+...+a[n][n]xn=a[n][n+1]
void Gauss_jordan(){
    /***** 行的交换&加减消元 *****/ 
    for(int i=1,r;i<=n;++i){	//正在处理第i行 
        r=i;
        for(int j=i+1;j<=n;++j) 
            if(fabs(a[j][i])>fabs(a[r][i])) r=j;
        if(fabs(a[r][i])<eps){
            puts("No Solution");return;
        }
        if(i!=r) swap(a[i],a[r]);
        
        for(int k=1;k<=n;++k){
            //每一行都处理  
            if(k==i) continue;
            double p=a[k][i]/a[i][i];
            for(int j=i;j<=n+1;++j) a[k][j]-=p*a[i][j];
        } 
    }	
    
    //上述操作后会剩下对角矩阵,答案要除以系数    
    for(int i=1;i<=n;++i) printf("%.2lf\n",a[i][n+1]/a[i][i]);
}


signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n+1;++j)
            scanf("%lf",&a[i][j]);
    Gauss_jordan();
}
```

## 矩阵求逆

> 高斯消元法

```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long
using namespace std;

ll read(){
    ll s=0,f=0;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-'),c=getchar();
    while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
    return f?-s:s;
}

const int N=405,mod=1e9+7;
int n;
ll a[N][N<<1];	//内有辅助矩阵，最终输出辅助矩阵 
ll qpow(ll x,ll k){
	ll ans=1;
	while(k){
		if(k&1) ans=ans*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return ans%mod;
}

void Gauss_j(){	
	for(int i=1,r;i<=n;++i){
		r=i;
		for(int j=i+1;j<=n;++j)
			if(a[j][i]>a[r][i]) r=j;
		if(r!=i) swap(a[i],a[r]);
		if(!a[i][i]){puts("No Solution");return;}
		
		int kk=qpow(a[i][i],mod-2);	//求逆元 
		for(int k=1;k<=n;++k){
			if(k==i) continue;
			int p=a[k][i]*kk%mod;
			for(int j=i;j<=(n<<1);++j) 
				a[k][j]=((a[k][j]-p*a[i][j])%mod+mod)%mod;
		} 
		
		for(int j=1;j<=(n<<1);++j) a[i][j]=(a[i][j]*kk%mod);
		//更新当前行 如果放在最后要再求一次逆元,不如直接放在这里  
	}	
	
	for(int i=1;i<=n;++i){
		for(int j=n+1;j<(n<<1);++j) printf("%lld ",a[i][j]);
		printf("%lld\n",a[i][n<<1]);
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			a[i][j]=read(),a[i][i+n]=1;
	
	Gauss_j();
    return 0;
}
```

> 快一点的奇妙方法

```c++
#include<bits/stdc++.h>
#define int64 long long
using namespace std;
const int64 mod=1e9+7;
int64 a[410][410];
int n,is[410],js[410];
void exgcd(int a,int b,int &x,int &y){
    if(!b)return x=1,y=0,void();
    exgcd(b,a%b,y,x);y-=x*(a/b);
}
int inv(int p){
    int x,y;exgcd(p,mod,x,y);
    return (x+mod)%mod;
}
void inv(){
    for(int k=1;k<=n;k++){
        for(int i=k;i<=n;i++) // 1
            for(int j=k;j<=n;j++)if(a[i][j]){
                is[k]=i,js[k]=j;break;
            }
        for(int i=1;i<=n;i++) // 2
            swap(a[k][i],a[is[k]][i]);
        for(int i=1;i<=n;i++)
            swap(a[i][k],a[i][js[k]]);
        if(!a[k][k]){
            puts("No Solution");
            exit(0);
        }
        a[k][k]=inv(a[k][k]); // 3
        for(int j=1;j<=n;j++)if(j!=k) // 4
            (a[k][j]*=a[k][k])%=mod;
        for(int i=1;i<=n;i++)if(i!=k) // 5
            for(int j=1;j<=n;j++)if(j!=k)
                (a[i][j]+=mod-a[i][k]*a[k][j]%mod)%=mod;
        for(int i=1;i<=n;i++)if(i!=k) // 就是这里不同
            a[i][k]=(mod-a[i][k]*a[k][k]%mod)%mod;
    }
    for(int k=n;k;k--){ // 6
        for(int i=1;i<=n;i++)
            swap(a[js[k]][i],a[k][i]);
        for(int i=1;i<=n;i++)
            swap(a[i][is[k]],a[i][k]);
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%lld",a[i]+j);
    inv();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            printf("%lld%c",a[i][j],j==n?'\n':' ');
    return 0;
}
```

# 行列式求值

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=602;
inline void read(register int &x)
{
	register int c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
int a[N][N];
int n,p,i,j;
int cal(int a[][N],register int n,const int p)
{
	register int i,j,k,r=1,fh=0,l;
	for (i=1;i<=n;i++)
	{
		k=i;
		for (j=i;j<=n;j++) if (a[j][i]) {k=j;break;}
		if (a[k][i]==0) return 0;
		for (++j;j<=n;j++) if (a[j][i]&&a[j][i]<a[k][i]) k=j;
		if (i!=k) {swap(a[k],a[i]);fh^=1;}
		for (j=i+1;j<=n;j++)
		{
			if (a[j][i]>a[i][i]) {swap(a[j],a[i]);fh^=1;}
			while (a[j][i])
			{
				l=a[i][i]/a[j][i];
				for (k=i;k<=n;k++) a[i][k]=(a[i][k]+(ll)(p-l)*a[j][k])%p;
				swap(a[j],a[i]);fh^=1;
			}
		}
		r=(ll)r*a[i][i]%p;
	}
	if (fh) return (p-r)%p;
	return r;
}
int main()
{
	read(n);read(p);
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) {read(a[i][j]);a[i][j]%=p;}
	printf("%d",cal(a,n,p));
}
```

# 拉格朗日插值

可以求$n^k$前缀和
$$
L(x)=\sum\limits_{i=0}^{n}y_{i}l_i(x)
$$


其中 
$$
l_i(x)=\prod_{j=0 \& j\neq i}^{n}\frac{x-x_j}{x_i-x_j}
$$


1. 需要组合数中的init。
2. arr: 插值数组  n: 项数(从0开始一共n+1项)  x: 需要求的值

> O(n<sup>2</sup>)

```c++
//n个点，求0～n-1的多项式系数，答案存在a数组，x和y从1开始存到n
ll a[maxn], b[maxn], c[maxn], temp[maxn];
ll x[maxn],y[maxn];
ll quick(ll x,ll n) {
    ll res=1;
    while(n) {
        if(n&1) res=res*x%mod;
        x=x*x%mod;
        n>>=1;
    }
    return res;
}
int n;
void mul(ll *f, int len, ll t){//len为多项式的次数+1，函数让多项式f变成f*(x+t)
    for(int i = len; i > 0; --i) temp[i] = f[i], f[i] = f[i-1];
    temp[0] = f[0], f[0] = 0;
    for(int i = 0; i <= len; ++i) f[i]=(f[i] + t*temp[i])%mod;
}
void dev(ll *f, ll *r, ll t){//f是被除多项式的系数，r保存f除以x+t的结果
    for(int i = 0; i <= n; ++i) temp[i] = f[i];
    for(int i = n; i > 0; --i){
        r[i-1] = temp[i];
        temp[i-1] = (temp[i-1] - t*temp[i]%mod+mod)%mod;
    }
    return;
}
void lglr()
{
    memset(temp,0,sizeof(temp));memset(b,0,sizeof(b));
    memset(c,0,sizeof(c));memset(a,0,sizeof a);
    b[1] = 1, b[0] = -x[1];
    for(int i = 2; i <= n; ++i) mul(b, i, -x[i]);//预处理(x-x1)*(x-x2)...*(x-xn)
    for(int i = 1; i <= n; ++i){
        ll fz = 1;
        for(int j = 1; j <= n; ++j){
            if(j == i) continue;
            fz = fz*(x[i] - x[j] + mod)%mod;
        }
        fz = quick(fz, mod-2);
        fz = fz*y[i]%mod;//得到多项式系数
        dev(b, c, -x[i]);//得到多项式，保存在b数组
        for(int j = 0; j < n; ++j) a[j] = (a[j] + fz*c[j]%mod)%mod;
    }
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n;
    for(int i=1;i<=n;++i) cin>>x[i]>>y[i];
    lglr();
    for(int i=0;i<n;++i) cout<<a[i]<<" ";
    return 0;
}
```

# 生成函数

生成函数（generating function），又称母函数，是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。

[入门题](https://www.luogu.com.cn/problem/P2000)

## 普通生成函数

<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/生成函数/生成函数基本运算.png" alt="生成函数基本运算" style="zoom: 50%;" />

## 普通生成函数的推广

$$
x\in(-1,1)\\
\sum_{i=0}^{\infin}x^{i}= \cfrac{1}{1-x}\\
x替换为-x：1-x+x^{2}-x^{3}+x^{4}-...+(-1)^{n}x^{n}+...=\cfrac{1}{1+x}\\
x替换为2x：1+2x+4x^{2}+8x^{3}+...+2^{n}x^{n}+...=\cfrac{1}{1-2x}\\
x替换为x^{2}：1+x^{2}+x^{4}+x^{6}+...+x^{2n}+...=\cfrac{1}{1-x^{2}}\\
分子乘\ 2：2+2x+2x^{2}+2x^{3}+...=\cfrac{2}{1-x}\\
分子乘x^{3}：x^{3}+x^{4}+x^{5}+x^{6}+...+x^{n}+...=\cfrac{x^{3}}{1-x}\\
求导：1+2x+3x^{2}+4x^{3}+...+(n+1)x^{n}+...=\cfrac{1}{(1-x)^{2}}\\
再求一次：2+6x+12x^{2}+...+(n+2)(n+1)x^{2}+...=\cfrac{2}{(1-x)^{3}}\\
有\cfrac{1}{(1-x)^{n}}=\sum_{k=0}^{\infin}C_{n+k-1}^{k-1}x^{k}
$$

补充：
$$
m是常数，n\geq0\\
F(x)=\sum_{n\geq0}^{m}C_m^{n}x^{n}=(1+x)^{m}（二项式展开）\\
F(x)=\sum_{n\geq0}C_{m+n}^{n}x^{n}=\cfrac{1}{(1-x)^{m+1}}(数学归纳法证)
$$

## 斐波那契数列的生成函数

斐波那契数列定义为
$$
a_{0}=0,a_{1}=1,a_{n}=a_{n-1}+a_{n-2}(n>1)
$$
设其普通生成函数为F(x)，可有
$$
F(x)=xF(x)+x^{2}F(x)-a_{0}x+a_{1}x+a_{0}
$$
可解得
$$
F(x)=\cfrac{x}{1-x-x^{2}}	\\
=\sum_{n\geq0}(x+x^{2})^{n}
$$
<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/生成函数/斐波那契生成函数.png" alt="斐波那契生成函数" style="zoom:50%;" />

## 卡特兰数的生成函数

$$
\sum_{n\geq0}C_{2n}^{n}\cfrac{1}{n+1}x^{n}
$$

## 指数生成函数

$$
e^{x}=\sum_{i=0}^{\infin}\cfrac{x^{i}}{i!}
$$

<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/生成函数/指数生成函数.png" alt="指数生成函数" style="zoom:150%;" />

（上面的图中e<sup>-x</sup>写错了，x要带上幂次）

# 积性函数

<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/积性函数/积性函数定义.png" alt="积性函数定义" style="zoom:50%;" />

<img src="/Users/davidxu/Desktop/算法笔记md/math_pic/积性函数/积性函数性质.png" alt="积性函数性质" style="zoom:50%;" />

积性函数都可以使用欧拉筛筛出来。

构造积性函数筛的思路：
$$
积性函数\sum_{d|n}d\cdot\phi(d)为例
$$
先定义
$$
g(n)=\sum_{d|n}d\cdot\phi(d)
$$
假设q为素数，由于
$$
g(n\cdot q^{k})=\sum_{d|nq^{k}}d\cdot\phi (d)\\
=g(n)+\sum_{t=1}^{k}q^{t}\sum_{d|n}d\cdot \phi(d) \cdot \phi(q^{t})\\
=g(n)\cdot[\ 1+\sum_{t=1}^{k}q^{t}\cdot \phi(q^{t})\ ]\\
=g(n)\cdot \sum_{d|q^{k}}d\cdot \phi(d)\\
=g(n)\cdot g(q^{k})
$$
得证它为积性函数。

类似可证
$$
g(n)=\sum_{d|n}d^{k}\phi(d),k\in N^+ 为积性函数
$$
考虑只有一种质因数的情况，即考虑素数的情况
$$
g(p_{j}^{k})=\sum_{w=0}^{k}p_{j}^{w}\cdot\phi(p_{j}^{w})\\
\phi(p_{j}^{w})=p_{j}^{w-1}\cdot(p_{j}-1)\\
\rightarrow g(p_{j}^{k})=\sum_{w=0}^{k}p_{j}^{2w-1}(p_{j}-1)
$$
再考虑
$$
g(p_{j}^{k+1})和g(p_{j}^{k})的递推\\
g(p_{j}^{k+1})=g(p_{j}^{k})+p_{j}^{2k+1}\cdot(p_{j}-1)\\
g(p_{j}^{k+1})-g(p_{j}^{k})=p_{j}^{2k+1}\cdot(p_{j}-1)
$$
考虑有两种质因数以上的情况，即考虑合数的情况
$$
记\ i=a\cdot p_{j}^{w},a为另一质数\\
类似等比数列，考虑\\
g(i\cdot p_{j})=g(a)\cdot g(p_{j}^{w+1})\\
g(i)=g(a)\cdot g(p_{j}^{w})\\
做差有\\
g(i\cdot p_{j})-g(i)=g(a)\cdot[\ g(p_{j}^{w+1})-g(p_{j}^{w})\ ]\\
=g(a)\cdot [\ p_{j}^{2w+1}\cdot(p_{j}-1)\ ]
$$
再考虑
$$
g(i)-g(\cfrac{i}{p_{j}})=g(a)\cdot [\ p_{j}^{2w-1}\cdot(p_{j}-1)\ ]
$$
得到仅于一个质因数有关的递推合数筛法
$$
g(i\cdot p_{j})=g(i)+[\ g(i)-g(\cfrac{i}{p_{j}})\ ]\cdot p_{j}^{2}
$$

```c++
const int maxn=1e6+10;
int prime[maxn];
bool sf[maxn];	//0为素数，1为合数
int g[maxn];
void init(){
	g[1]=1;
	int num=0;
	for(int i=2;i<=maxn;++i){
		if(!sf[i])	prime[++num]=i,g[i]=1ll*i*(i-1)+1;
		for(int j=1;j<=num && i*prime[j]<=maxn;++j){
			sf[i*prime[j]]=1;
			if(i%prime[j]==0){
				g[i*prime[j]]=g[i]+(g[i]-g[i/prime[j]])*prime[j]*prime[j];
				break;
			}
			g[i*prime[j]]=g[i]*g[prime[j]];
		}
	}
}
```

> 常见积性函数

1. 莫比乌斯函数𝜇(𝑛)
2. 欧拉函数𝜑(𝑛)

$$
\phi(n)=\sum_{i=1}^{n}[\ (n,i)=1\ ]
$$

3. 约数函数𝑑(𝑛)，约数个数
   $$
   d(n)=\sum_{d|n}1
   $$

4. 约数和函数𝜎(𝑛)，各个约数之和

$$
\sigma(n)=\sum_{d|n}d=\sum_{d=1}^{n}[\ d|n\ ]\cdot d
$$

## 一些辅助函数

1. 元函数𝜖(𝑛)=[n=1]
2. 恒等函数𝐼(𝑛)=1
3. 单位函数𝑖𝑑(𝑛)=n

# 狄利克雷卷积

$$
(f*g)(n)=\sum_{d|n}f(d)\cdot g(\cfrac{n}{d})
$$

>  运算规律（类似乘法）

1. 交换律(f∗g=g∗f)
2. 结合律(f∗g)∗h=f∗(g∗h)
3. 分配律(f+g)∗h=f∗h+g∗h

> 单位元

元函数𝜖(𝑛)=[n=1]
$$
f∗ϵ=f
$$

> 重要小结论

莫比乌斯函数
$$
\mu*I=\epsilon
$$
欧拉函数
$$
\phi*I=id
$$

转化
$$
\mu*id=\phi
$$


# 莫比乌斯函数(要记得取模时mu+mod)

> μ(d)的定义是:

1. 当d=1时，μ(d)=1；
   $$
   d=\prod_{i=1}^{k}pi
   $$

2. 上式pi为互异素数时，μ(d)=(−1)<sup>k</sup>。(说直白点，就是d分解质因数后，没有幂次大于2的质因子，此时函数值根据分解的个数决定)；

3. 只要当d含有任何质因子的幂次大于等于2，则函数值为0.

## 莫比乌斯筛

```c++
const int maxn=1e5+10;
int mu[maxn];
int prime[maxn];
bool sf[maxn];
void sushu()
{
	int num=0;
	memset(sf,1,sizeof sf);
	for(int i=2;i<maxn;i++)
	{
		if(sf[i]) prime[++num]=i,mu[i]=-1;
		for(int j=1;j<=num && i*prime[j]<maxn;j++){
			sf[i*prime[j]]=0;
			if(i%prime[j]==0) break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	mu[1]=1;
	sf[0]=sf[1]=0;
}
```

> 取模版

```c++
const int maxn=1e5+10;
int mu[maxn];
int prime[maxn];
bool sf[maxn];
void sushu()
{
	int num=0;
	memset(sf,1,sizeof sf);
	for(int i=2;i<=maxn;i++)
	{
		if(sf[i]) prime[++num]=i,mu[i]=(mod-1)%mod;
		for(int j=1;j<=num;j++){
			if(i*prime[j]>maxn) break;
			sf[i*prime[j]]=0;
			if(i%prime[j]==0) break;
			mu[i*prime[j]]=(mod-mu[i])%mod;
		}
	}
	mu[1]=1;
	sf[0]=sf[1]=0;
}
```



## 莫比乌斯函数的性质

1. \[n=1\]表示只有当n=1成立时，返回值为1；否则，值为0

$$
\sum_{d|n}\mu(d)=[n=1]
$$

2. 狄利克雷卷积形式
   $$
   \mu*I=\epsilon
   $$
   莫比乌斯函数和恒等函数做狄利克雷卷积=元函数

3. 

$$
\sum_{d|n}\cfrac{\mu(d)}{d}=\cfrac{\phi(n)}{n}
$$

## 莫比乌斯反演

- 定理：F(n)和f(n)是定义在非负整数集合上的两个函数，并且满足条件：
  $$
  F(n)=\sum_{d|n}f(d)
  $$
  有
  $$
  若n=p^{2}(p为质数),\\
  F(p)=f(1)+f(p)\\
  F(n)=f(1)+f(p)+f(p^{2})\\
  f(n)=F(p^{2})-F(p)
  $$
  则猜测存在（实际上是对的）
  $$
  f(n)=\sum_{d|n}\mu(d) F(\cfrac{n}{d})
  $$

  > 另一种形式

  $$
  F(n)=\sum_{n|d}f(d)\\
  f(n)=\sum_{n|d}\mu(\cfrac{d}{n})F(d)
  $$

  > 莫比乌斯反演的性质

  1. *μ*(*n*)是积性函数
  2. 设*f*是算术函数，如果它的和函数F(n)是积性函数，那么 *f* 也是积性函数。
  

## 经典公式

1. $\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=1]$

$$
由于\sum_{d|n}\mu(d)=[\ n=1\ ]当且仅当n=1时才为1，其余情况为0\\
根据莫比乌斯反演，可构造\epsilon(n)=\sum_{d|n}\mu(d)\sum_{d'|\cfrac{n}{d}}\epsilon(d')=\sum_{d|n}\mu(d)\\
所以有\epsilon(gcd(i,j))=[gcd(i,j)=1]=\sum_{d|gcd(i,j)}\mu(d)\\
$$

所以原式可化为
$$
\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=1]=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d|gcd(i,j)}\mu(d)\\
=\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}1\\
=\sum_{d=1}^{min(n,m)}\mu(d)\lfloor\cfrac{n}{d}\rfloor\lfloor\cfrac{m}{d}\rfloor
$$
由于有部分d的$\lfloor\cfrac{n}{d}\rfloor$或$\lfloor\cfrac{m}{d}\rfloor$值相同，因此对d分块，预处理$\mu(d)$的前缀和处理

```c++
int ans=0;
	for(int L=1,R;L<=min(n,m);L=R+1) {
		R=min(n/(n/L),m/(m/L));
		ans=ans+(premu[R]-premu[L-1])*(n/L)*(m/L);
	}
return ans;
```

2. $\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=k]$

$$
\sum_{i=x}^{n}\sum_{j=y}^{m}[gcd(i,j)=k]\\
化简为\sum_{i=1}^{\lfloor \cfrac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \cfrac{m}{k}\rfloor}[gcd(i,j)=1]\\
同理得\sum_{d=1}^{min(\cfrac{n}{k},\cfrac{m}{k})}\mu(d)\lfloor\cfrac{n}{dk}\rfloor\lfloor\cfrac{m}{dk}\rfloor
$$
3. $\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)$

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)=\sum_{d=1}^{min(n,m)}\sum_{i=1}^{n}\sum_{j=1}^{m}d[\ gcd(i,j)=d\ ]\\
=\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}[\ gcd(i,j)=1\ ]\\
=\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}\sum_{t|gcd(i,j)}\mu(t)\\
=\sum_{d=1}^{min(n,m)}d\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\lfloor\cfrac{n}{dt}\rfloor\lfloor\cfrac{m}{dt}\rfloor
$$
至此仍为O(n)算法，令T=dt，要使$\lfloor\cfrac{n}{dt}\rfloor>0$，$\lfloor\cfrac{m}{dt}\rfloor>0$，枚举T=dt=1,2,...,min(n,m)
$$
\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)=\sum_{T=1}^{min(n,m)}\lfloor\cfrac{n}{T}\rfloor\lfloor\cfrac{m}{T}\rfloor\sum_{d|T}\mu(d)(\cfrac{T}{d})
$$
由于$\sum_{d|T}\mu(d)(\cfrac{T}{d})=(\mu*id)(T)=\phi(T)$

所以有
$$
\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)=\sum_{T=1}^{min(n,m)}\lfloor\cfrac{n}{T}\rfloor\lfloor\cfrac{m}{T}\rfloor\phi(T)
$$
分块复杂度为O(sqrt(n))，n,m较大时，使用杜教筛查询$\phi(T)$前缀和。

另外可使用欧拉反演，核心公式为$\sum_{d|n}\phi(d)=n$
$$
gcd(i,j)=\sum_{d|gcd(i,j)}\phi(d)\\
\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{d|gcd(i,j)}\phi(d)\\
=\sum_{d=1}^{min(n,m)}\phi(d)\sum_{i=1}^{n}\sum_{j=1}^{m}[\ d|gcd(i,j)\ ]\\
=\sum_{d=1}^{min(n,m)}\phi(d)\sum_{i=1}^{n}\sum_{j=1}^{m}[\ d|i,d|j\ ]\\
=\sum_{d=1}^{min(n,m)}\phi(d)\sum_{i=1}^{n}[d|i]\sum_{j=1}^{m}[d|j]\\
==\sum_{d=1}^{min(n,m)}\phi(d)\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}[1|i]\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}[1|j]\\
=\sum_{d=1}^{min(n,m)}\lfloor\cfrac{n}{d}\rfloor\lfloor\cfrac{m}{d}\rfloor\phi(d)
$$

4. $\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)=\sum_{i=1}^{n}\sum_{j=1}^{m}\cfrac{ij}{gcd(i,j)}\\
=\sum_{d=1}^{min(n,m)}\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}\cfrac{idjd}{d}[\ gcd(i,j)=1\ ]\\
=\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}ij\sum_{t|i,t|j\iff t|gcd(i,j)}\mu(t)\\
=\sum_{d=1}^{min(n,m)}d\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{dt}\rfloor}ij\cdot t^{2}\\
=\sum_{d=1}^{min(n,m)}d\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\cdot t^{2}\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}i\sum_{j=1}^{\lfloor\cfrac{m}{dt}\rfloor}j\\
=\sum_{d=1}^{min(n,m)}d\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\cdot t^{2}\cdot sum(\lfloor\cfrac{n}{dt}\rfloor)\cdot sum(\lfloor\cfrac{m}{dt}\rfloor)
$$

当n=m，记$f(n)=\sum_{t=1}^{n}\mu(t)\cdot t^{2}\cdot sum(\lfloor\cfrac{n}{t}\rfloor)^{2}$，可在O(sqrt(n))内求出。
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}lcm(i,j)=\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\cfrac{n}{d}\rfloor}\mu(t)\cdot t^{2}\cdot sum(\lfloor\cfrac{n}{dt}\rfloor)^{2}
\\=\sum_{d=1}^{n}d\cdot f(\lfloor\cfrac{n}{d}\rfloor)
$$
也是O(sqrt(n))分块，因此总体复杂度为O(sqrt(n))*O(sqrt(n))=O(n)。

$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$分块同理。

5. $\sum_{i=1}^{n}\sum_{j=1}^{m}ijgcd(i,j)$

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}ijgcd(i,j)=\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{n}\sum_{j=1}^{m}ij[\ gcd(i,j)=d\ ]\\
=\sum_{d=1}^{min(n,m)}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}idjd\sum_{t|i,t|j}\mu(t)\\
=\sum_{d=1}^{n}d^{3}\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}it\sum_{j=1}^{\lfloor\cfrac{m}{dt}\rfloor}jt\\
=\sum_{d=1}^{n}d^{3}\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\cdot t^{2}\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}i\sum_{j=1}^{\lfloor\cfrac{m}{dt}\rfloor}j\\
=\sum_{d=1}^{n}d^{3}\sum_{t=1}^{min(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)}\mu(t)\cdot t^{2}\cdot sum(\lfloor\cfrac{n}{dt}\rfloor)\cdot sum(\lfloor\cfrac{m}{dt}\rfloor)\\
$$

类似公式4的推导，此时的整体复杂度为O(n)。

以下讨论n=m的情况，令dt=T
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}ijgcd(i,j)=\sum_{T=1}^{n}sum(\lfloor\cfrac{n}{T}\rfloor)^{2}\sum_{t|T}\mu(t)\cdot t^{2}\cdot (\cfrac{T}{t})^{3}\\
=\sum_{T=1}^{n}sum(\lfloor\cfrac{n}{T}\rfloor)^{2}\cdot T^{2}\sum_{t|T}\mu(t)\cdot (\cfrac{T}{t})\\
$$
由于$\mu*id=\phi$
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}ijgcd(i,j)=\sum_{T=1}^{n}sum(\lfloor\cfrac{n}{T}\rfloor)^{2}\cdot T^{2}\phi(T)
$$
预处理$T^{2}\phi(T)$的前缀和，再分块，复杂度为O(sqrt(n))。

当n较大时，需要杜教筛算出$T^{2}\phi(T)$的前缀和。

```c++
const int maxn=8000000;
bool sf[maxn];
int prime[maxn];
int sum_t2phi[maxn];
int phi[maxn];
int num=0;
int mod;

void init(){
	phi[1]=1;
    sf[1]=1,sf[0]=1;
	for(int i=2;i<maxn;++i){
		if(!sf[i]) prime[++num]=i,phi[i]=(i-1+mod)%mod;
		for(int j=1;j<=num&&i*prime[j]<maxn;++j){
			sf[i*prime[j]]=1;
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j]%mod;
				break;
			}
			phi[i*prime[j]]=phi[i]*phi[prime[j]]%mod;
		}
	}
	for(int i=1;i<maxn;++i){
		sum_t2phi[i]=(sum_t2phi[i-1]+phi[i]*i%mod*i%mod)%mod;
	}
}
ll qpowMod(ll n,ll m)
{
    ll res=1;
    ll multi=n;
    while(m){
        if(m&1){
            res=(res*multi)%mod;
        }
        multi=(multi*multi)%mod;
        m>>=1;
    }
    return res;
}
int inv6,inv2;
int sum2(int x){
    x=x%mod;
    return x*(x+1)%mod*inv2%mod;
}
int sum3(int x){
    x=x%mod;
    return x*(x+1)%mod*(x+x+1)%mod*inv6%mod;
}
unordered_map<int,int> mp;
int djs(int x){
	if(x<maxn) return sum_t2phi[x];
	if(mp.count(x)) return mp[x];
    int ans=sum2(x);
	ans=ans*ans%mod;
	for(int l=2,r;l<=x;l=r+1){
        r=x/(x/l);
        int tt=(sum3(r)-sum3(l-1)+mod)%mod;
		ans=(ans-djs(x/l)*tt%mod+mod)%mod;
	}
	return mp[x]=ans;
}
int n;
int solve(){
	cin>>mod>>n;
	inv6=qpowMod(6,mod-2);
    inv2=qpowMod(2,mod-2);
    init();
	int ans=0;
	for(int l=1,r;l<=n;l=r+1){
		r=n/(n/l);
        int sum=sum2(n/l);
        int pre=(djs(r)-djs(l-1)+mod)%mod;
        sum=sum*sum%mod;
		ans=(ans+sum*pre%mod)%mod;
	}
	return ans;
}
signed main(){
	IOFast();
	cout<<solve()<<'\n';
}
```

6. $\sum_{i=1}^{n}\sum_{j=1}^{m}[\ gcd(i,j)=1\ ]i\cdot j$

$$
\sum_{i=1}^{n}\sum_{j=1}^{m}[\ gcd(i,j)=1\ ]i\cdot j\\
=\sum_{i=1}^{n}\sum_{j=1}^{m}\epsilon(gcd(i,j))\cdot i\cdot j\\
=\sum_{d=1}^{n}\sum_{d|i}^{n}\sum_{d|j}^{m}\mu(d)\cdot i\cdot j\\
=\sum_{d=1}^{n}\mu(d)\cdot d^{2}\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{m}{d}\rfloor}i\cdot j\\
令g(n,m)=\sum_{i=1}^{n}\sum_{j=1}^{m}i\cdot j=\cfrac{n\cdot(n+1)}{2}\cross\cfrac{m\cdot(m+1)}{2}\\
原式=\sum_{d=1}^{n}\mu(d)\cdot d^{2}\cdot g(\lfloor\cfrac{n}{d}\rfloor,\lfloor\cfrac{m}{d}\rfloor)\\
二维分块计算
$$



7. $\sum_{i=1}^{n}\sum_{j=1}^{n}lcm(a_{i},a_{j})$

$$
\sum_{i=1}^{n}\sum_{j=1}^{n}lcm(a_{i},a_{j})=\sum_{i=1}^{n}\sum_{j=1}^{n}\cfrac{a_{i}a_{j}}{gcd(a_{i},a_{j})}\\
=\sum_{i=1}^{n}\sum_{j=1}^{n}cnt_{i}cnt_{j}\cfrac{ij}{gcd(i,j)}\\
=\sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{n}cnt_{i}cnt_{j}\cfrac{ij}{d}[\ gcd(i,j)=d\ ]\\
=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{n}{d}\rfloor}cnt_{id}cnt_{jd}ij[\ gcd(i,j)=1\ ]\\
=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\cfrac{n}{d}\rfloor}cnt_{id}cnt_{jd}ij\sum_{t|i,t|j}\mu(t)\\
=\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\cfrac{n}{d}\rfloor}\mu(t)t^{2}\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}icnt_{idt}\sum_{j=1}^{\lfloor\cfrac{n}{dt}\rfloor}jcnt_{jdt}\\
=\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\cfrac{n}{d}\rfloor}\mu(t)t^{2}(\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}icnt_{idt})^{2}
$$

令T=dt，
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}lcm(a_{i},a_{j})=\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}i\cdot cnt_{iT})^{2}\sum_{t|T}\mu(t)t^{2}(\cfrac{T}{t})\\
=\sum_{T=1}^{n}T(\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}i\cdot cnt_{iT})^{2}\sum_{t|T}\mu(t)t
$$
对于$\sum_{t|T}\mu(t)t^{2}$，记为$f(T)$，可以O(nlogn)预处理，枚举t，从下而上算贡献。

```c++
for (int t = 1; t <= n; t++)
        for (int T = t; T <= n; T += t)
            f[T] += mu[t] * t;
```

$(\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}i\cdot cnt_{iT})^{2}$为关于T的函数，记$s(T)=\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}i\cdot cnt_{iT}=\cfrac{1}{T}\sum_{T|t}t\cdot cnt_{t}$，对于特定T，枚举它的倍数t，O(nlogn)预处理。

```c++
for (int T = 1; T <= n; T++) {
        for (int t = T; t <= n; t += T)
            s[T] += t * cnt[t];
        s[T] /= T;
    }
```

```c++
const int maxn=5e4+10;
int mu[maxn];
int prime[maxn];
bool sf[maxn];
int s[maxn],f[maxn];
int num=0;
int cnt[maxn];
int n;
int mx;
void init(){
	cin>>n;
	for(int i=1;i<=n;++i){
		int now;
		cin>>now;
		cnt[now]++;
		mx=max(mx,now);
	}
	mu[1]=1;
	sf[0]=sf[1]=1;
	for(int i=2;i<maxn;i++)
	{
		if(!sf[i]) prime[++num]=i,mu[i]=-1;
		for(int j=1;j<=num && i*prime[j]<maxn;j++){
			sf[i*prime[j]]=1;
			if(i%prime[j]==0) break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int t=1;t<=mx;++t){
		for(int T=t;T<=mx;T+=t){
			f[T]+=mu[t]*t;
		}
	}
	for(int T=1;T<=mx;++T){
		for(int t=T;t<=mx;t+=T){
			s[T]+=t*cnt[t];
		}
		s[T]/=T;
	}
}
int solve(){
	int ans=0;
	for(int i=1;i<=mx;++i){
		ans+=i*s[i]*s[i]*f[i];
	}
	return ans;
}
```

8. $\sum_{i=1}^{n}lcm(i,n)$

$$
\sum_{i=1}^{n}lcm(i,n)=\sum_{i=1}^{n}\cfrac{i\cdot n}{gcd(i,n)}\\
=\cfrac{1}{2}\cdot (\sum_{i=1}^{n-1}\cfrac{i\cdot n}{gcd(i,n)}+\sum_{i=1}^{n-1}\cfrac{(n-i)\cdot n}{gcd(n-i,n)})+n\\
=\cfrac{1}{2}\cdot (\sum_{i=1}^{n-1}\cfrac{i\cdot n}{gcd(i,n)}+\sum_{i=1}^{n-1}\cfrac{(n-i)\cdot n}{gcd(i,n)})+n\\
=\cfrac{1}{2}\cdot \sum_{i=1}^{n-1}\cfrac{n^{2}}{gcd(i,n)}+n\\
=\cfrac{1}{2}\cdot \sum_{i=1}^{n}\cfrac{n^{2}}{gcd(i,n)}+\cfrac{n}{2}\\
考虑相同的gcd(i,n)一起计算，枚举gcd(i,n)=d，\\
=\cfrac{1}{2}\cdot \sum_{d=1}^{n}\cfrac{n^{2}}{d}[\ gcd(\cfrac{i}{d},\cfrac{n}{d})=1\ ]+\cfrac{n}{2}\\
=\cfrac{1}{2}\cdot \sum_{d|n}\cfrac{n^{2}\cdot \phi(\cfrac{n}{d})}{d}+\cfrac{n}{2}
$$

令$d'=\cfrac{n}{d}$，
$$
\sum_{i=1}^{n}lcm(i,n)=\cfrac{1}{2}n\cdot \sum_{d'|n} d'\phi(d')+\cfrac{n}{2}
$$

同样可以枚举d'向上算贡献，O(nlogn)预处理，积性函数章有O(n)筛法。

9. $f(a,n)=\sum_{i=1}^{n}gcd(a,i)$

$$
f(a,n)=\sum_{d|a}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}[\ gcd(\cfrac{a}{d},i)=1\ ]\\
=\sum_{d|a}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{t|\cfrac{a}{d},t|i}\mu(t)\\
=\sum_{d|a}d\sum_{t|\cfrac{a}{d}}\mu(t)\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}1\\
=\sum_{d|a}d\sum_{t|\cfrac{a}{d}}\mu(t)\lfloor\cfrac{n}{dt}\rfloor
$$

令T=dt，
$$
f(a,n)=\sum_{T|a}\sum_{t|T}\mu(t)\cdot(\cfrac{T}{t})\cdot \lfloor\cfrac{n}{T}\rfloor\\
=\sum_{T|a}\lfloor\cfrac{n}{T}\rfloor\cdot\phi(T)
$$

10. $\sum_{i=1}^{N}gcd(\lfloor\sqrt[3]{i}\rfloor,i)$

[原题链接](http://acm.hdu.edu.cn/showproblem.php?pid=6588)

记$n=\lfloor\sqrt[3]{N}\rfloor$
$$
\sum_{i=1}^{N}gcd(\lfloor\sqrt[3]{i}\rfloor,i)=\sum_{i=1}^{n}\sum_{j=i^{3}}^{min(N,(i+1)^{3}-1)}gcd(i,j)\\
=\sum_{i=1}^{n-1}\sum_{j=i^{3}}^{(i+1)^{3}-1}gcd(i,j)+\sum_{j=n^{3}}^{N}gcd(n,j)\\
$$
先算前半部分，记$f(n)=\sum_{i=1}^{n}\sum_{j=i^{3}}^{(i+1)^{3}-1}gcd(i,j)$，所求的是$f(n-1)$
$$
f(n)=\sum_{i=1}^{n}\sum_{j=i^{3}}^{(i+1)^{3}-1}gcd(i,j)\\
=\sum_{d=1}^{n}d\sum_{i=1}^{n}\sum_{j=i^{3}}^{(i+1)^{3}-1}[\ gcd(i,j)=d\ ]\\
=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor\cfrac{n}{d}\rfloor}\sum_{j=\lfloor\cfrac{(id)^{3}}{d}\rfloor}^{\lfloor\cfrac{(id+1)^{3}-1}{d}\rfloor}\sum_{t|i,t|j}\mu(t)\\
=\sum_{d=1}^{n}d\sum_{t=1}^{\lfloor\cfrac{n}{d}\rfloor}\mu(t)\sum_{i=1}^{\lfloor\cfrac{n}{dt}\rfloor}\sum_{j=\lfloor\cfrac{(idt)^{3}}{dt}\rfloor}^{\lfloor\cfrac{(idt+1)^{3}-1}{dt}\rfloor}1\\
$$
老方法，令T=dt，
$$
f(n)=\sum_{T=1}^{n}\sum_{t|T}\mu(t)\cdot (\cfrac{T}{t})\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}\sum_{j=\lfloor\cfrac{(iT)^{3}}{T}\rfloor}^{\lfloor\cfrac{(iT+1)^{3}-1}{T}\rfloor}1\\
=\sum_{T=1}^{n}\phi(T)\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}\sum_{j=\lfloor\cfrac{(iT)^{3}}{T}\rfloor}^{\lfloor\cfrac{(iT+1)^{3}-1}{T}\rfloor}1\\
令g(n,T)=\sum_{i=1}^{\lfloor\cfrac{n}{T}\rfloor}\sum_{j=\lfloor\cfrac{(iT)^{3}}{T}\rfloor}^{\lfloor\cfrac{(iT+1)^{3}-1}{T}\rfloor}1\\
g(n,T)=\sum_{i=1}^{\lfloor{\cfrac{n}{T}}\rfloor}(3i^{2}T+3i+1)\\
=3T\sum_{i=1}^{\lfloor \cfrac{n}{T}\rfloor}i^{2}+3\sum_{i=1}^{\lfloor \cfrac{n}{T}\rfloor}i+\lfloor \cfrac{n}{T}\rfloor
$$
综上可O(n)得到$f(n)=\sum_{T=1}^{n}g(n,T)\phi(T)$，接下来求$\sum_{j=n^{3}}^{N}gcd(n,j)$
$$
\sum_{j=n^{3}}^{N}gcd(n,j)=\sum_{d|n}d\sum_{j=\lfloor\cfrac{n^{3}}{d}\rfloor}^{\lfloor\cfrac{N}{d}\rfloor}[\ gcd(\cfrac{n}{d},j)=1\ ]\\
=\sum_{d|n}d\sum_{j=\lfloor\cfrac{n^{3}}{d}\rfloor}^{\lfloor\cfrac{N}{d}\rfloor}\sum_{t|\cfrac{n}{d},t|j}\mu(t)\\
=\sum_{d|n}d\sum_{td|n}\mu(t)\sum_{j=\lfloor\cfrac{n^{3}}{dt}\rfloor}^{\lfloor\cfrac{N}{dt}\rfloor}1\Leftarrow T=dt\\
=\sum_{T|n}\left( \sum_{j=\lfloor\cfrac{n^{3}}{T}\rfloor}^{\lfloor\cfrac{N}{T}\rfloor}1\right)\sum_{d|T}\mu(\cfrac{T}{d})d\\
=\sum_{T|n}\left( \sum_{j=\lfloor\cfrac{n^{3}}{T}\rfloor}^{\lfloor\cfrac{N}{T}\rfloor}1\right) \phi(T)\\
=\sum_{T|n}(\lfloor\cfrac{N}{T}\rfloor-\lfloor\cfrac{n^{3}}{T}\rfloor+1)\phi(T)
$$
此部分O(sqrt(n))求出
$$
\sum_{i=1}^{N}gcd(\lfloor\sqrt[3]{i}\rfloor,i)=\sum_{T=1}^{n-1}\phi(T)\cdot \left( 3T\sum_{i=1}^{\lfloor \cfrac{n-1}{T}\rfloor}i^{2}+3\sum_{i=1}^{\lfloor \cfrac{n-1}{T}\rfloor}i+\lfloor \cfrac{n-1}{T}\rfloor \right) +\sum_{T|n}\phi(T)\cdot \left(\lfloor\cfrac{N}{T}\rfloor-\lfloor\cfrac{n^{3}}{T}\rfloor+1\right)
$$
需要注意的是，枚举T|n时，

```c++
for(int T=1;T*T<=n;++T){
  if(n%T) continue;
  ans+=f(T);
  if(T*T!=n)
    ans+=f(n/T);
}
```

```c++
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
#define int ll
#define ull unsigned long long
#define pii pair<int,int>
#define vc vector
#define vi vector<int>
#define db double
#define PI acos(-1.0)
#define forn(i, n) for (int i = 1; i <= n; ++i)
#define forr(i, n) for (int i = n; i >= 1; --i)
#define IOFast() ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#ifndef ONLINE_JUDGE
#define dbg(x...) do { cout << "\033[33;1m " << #x << " -> "; err(x); } while (0)
void err() { cout << "\033[39;0m" << endl; }
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }
template<typename T, typename... A>
void err(T a, A... x) { cout << a << ' '; err(x...); }
#else
#define dbg(...)
#endif

const int maxn=1e7+10;
const int mod=998244353;
template <class T>
void read(T &x) {
	static char ch;static bool neg;
	for(ch=neg=0;ch<'0' || '9'<ch;neg|=ch=='-',ch=getchar());
	for(x=0;'0'<=ch && ch<='9';(x*=10)+=ch-'0',ch=getchar());
	x=neg?-x:x;
}
int prime[maxn];
bool sf[maxn];
int phi[maxn];
int num=0;
void init(){
	sf[0]=sf[1]=1;
	phi[1]=1;
	for(int i=2;i<maxn;++i){
		if(!sf[i]) prime[++num]=i,phi[i]=i-1;
		for(int j=1;j<=num&&i*prime[j]<maxn;++j){
			sf[i*prime[j]]=1;
			if(i%prime[j])
				phi[i*prime[j]]=1ll*phi[i]*(prime[j]-1)%mod;
			else{
				phi[i*prime[j]]=1ll*phi[i]*prime[j]%mod;
				break;
			}
		}
	}
}
int tripleroot(__int128 x){		//二分求三次根号
	__int128 l=1,r=1e7;
	int res = 0;
	while(l<=r){
		__int128 mid=(l+r)/2;
		if(mid*mid*mid<=x){
			res=mid;
			l=mid+1;
		}
		else {
			r=mid-1;
		}
	}
	return (int)res;
}

ll qpowMod(ll n,ll m)
{
	ll res=1;
	while(m!=0){
			if((m&1)==1) res=(res*n)%mod;
			n=(n*n)%mod;
			m>>=1;
		}
	return res;
}
int inv6=qpowMod(6, mod-2),inv2=qpowMod(2, mod-2);

int mp1[maxn];
int sum(int & x){
	if(mp1[x]) return mp1[x];
	return mp1[x]=1ll*x*(1+x)/2%mod;
}
	
int mp2[maxn];
int sum2(int & x){
	if(mp2[x]) return mp2[x];
	return mp2[x]=1ll*x*(x+1)%mod*(x+x+1)%mod*inv6%mod;
}
ll calc(__int128 x,__int128 &x3){
	__int128 ans=0;
	for(int i=1;i*i<=x;++i){
		if(x%i) continue;
		ll T=i;
		ans+=phi[T]*(x3/T-x*x*x/T+1+mod)%mod;	
		ans%=mod;
		if(T*T==x)continue;
		T=x/T;
		ans+=phi[T]*(x3/T-x*x*x/T+1+mod)%mod;	
		ans%=mod;
	}
	return (ll)ans;
}
ll f(int n,int &T){
	int div=n/T;
	return (3ll*T*sum2(div)%mod+3ll*sum(div)%mod+div)%mod;
}
ll solve(){
	__int128 N;
	read(N);
	int n=tripleroot(N);
	ll ans=calc(n,N);				//后半部分
	for(int T=1;T<=n-1;++T){
		ans+=phi[T]*f(n-1,T)%mod;	//前半部分
		ans%=mod;
	}
	return ans;
}
signed main(){
	init();
	int t;
	read(t);
	while(t--)
		printf("%lld\n",solve());
}
```

> 莫比乌斯+容斥+分块

求 i 属于a~b，j 属于c~d有多少个gcd(i,j)=k

```c++
const int maxn=5e4+10;
int prime[maxn];
int premu[maxn];
int mu[maxn];
bool sf[maxn];
void init(){
	int num=0;
	memset(sf,1,sizeof sf);
	for(int i=2;i<=maxn;++i){
		if(sf[i]) prime[++num]=i,mu[i]=-1;	
		for(int j=1;j<=num;++j){
			if(i*prime[j]>=maxn)break;
			sf[i*prime[j]]=0;
			if(i%prime[j]==0)break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	mu[1]=1;
	sf[0]=sf[1]=0;
	for(int i=1;i<maxn;i++)
		premu[i]=premu[i-1]+mu[i];
}

int a,b,c,d,k;
int mx;
int calc(int tp1,int tp2){
	if(tp1==0||tp2==0) return 0;
	int ans=0;
	for(int l=1,r;l<=min(tp1,tp2);l=r+1){
		r=min(tp1/(tp1/l),tp2/(tp2/l));
		ans+=(premu[r]-premu[l-1])*(tp1/l)*(tp2/l);	
	}
	return ans;
}
void solve(){
	cin>>a>>b>>c>>d>>k;
	a=(a-1)/k,b/=k,c=(c-1)/k,d/=k;
	mx=max(b,d);
	int res=calc(b,d)-calc(a,d)-calc(b,c)+calc(a,c);
	cout<<res<<'\n';
}
signed main(){
	IOFast();
	int t;
	init();
	cin>>t;
	while(t--) solve();
}
```

11. $\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)$

d(x)为约数个数
$$
d(ij)=\sum_{x|i}\sum_{y|j}[\ gcd(x,y)=1\ ]\\
=\sum_{x|i}\sum_{y|j}\sum_{p|gcd(x,y)}\mu(p)\\
=\sum_{p=1}^{min(i,j)}\sum_{x|i}\sum_{y|j}[\ p|gcd(x,y)\ ]\cdot \mu(p)\\
=\sum_{p|i,p|j}\mu(p)\sum_{x|\cfrac{i}{p}}\sum_{y|\cfrac{j}{p}}1\\
=\sum_{p|i,p|j}\mu(p)d(\cfrac{i}{p})d(\cfrac{j}{p})\\
\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{p|i,p|j}\mu(p)d(\cfrac{i}{p})d(\cfrac{j}{p})\\
=\sum_{p=1}^{min(n,m)}\mu(p)\sum_{i=1}^{\lfloor\cfrac{n}{p}\rfloor}d(i)\sum_{j=1}^{\lfloor\cfrac{m}{p}\rfloor}d(j)\\
=\sum_{p=1}^{min(n,m)}\mu(p)Sumd\left( \lfloor \cfrac{n}{p}\rfloor \right)Sumd\left( \lfloor \cfrac{m}{p}\rfloor \right)
$$
O(n)预处理$\mu,d的前缀和$，$O(\sqrt{n})$分块询问。

# 曼哈顿距离和切比雪夫距离

> 曼哈顿距离

dis=abs(x1-x2)+abs(y1-y2)

> 切比雪夫距离

dis=max(abs(x1-x2),abs(y1-y2))

>  转化关系

原(x,y)坐标变为(x+y,x-y)，原坐标系的曼哈顿距离==新坐标系的切比雪夫距离

原(x,y)坐标变为(x+y/2,x-y/2)，愿坐标系的切比雪夫距离==新坐标系的曼哈顿距离

# Burnside & Polya

* $|X/G|={\frac  {1}{|G|}}\sum _{{g\in G}}|X^{g}|$

注：$X^g$ 是 $g$ 下的不动点数量，也就是说有多少种东西用 $g$ 作用之后可以保持不变。

* $|Y^X/G| = \frac{1}{|G|}\sum_{g \in G} m^{c(g)}$

注：用 $m$ 种颜色染色，然后对于某一种置换 $g$，有 $c(g)$ 个置换环，为了保证置换后颜色仍然相同，每个置换环必须染成同色。

# 皮克定理

$2S = 2a+b-2$

* $S$ 多边形面积
* $a$ 多边形内部点数
* $b$ 多边形边上点数

# 一些需要特判的例子

1. %mod意义下，0和1\*mod和2\*mod...n\*mod的逆元没有意义

   因此，如果数据大于模数，需要特判	p*mod	或者不用逆元

2. 1<sup>k</sup>=1，0<sup>k</sup>=0，0的0次方没有意义

3. 下界0或1

4. 超大数

5. 1的欧拉函数是1，互质的定义是gcd(i,j)==1

# 小结论

1. 1-10的LCM为2520

2. 右手摸墙走，一定能走到迷宫出口，除非是初始位置在一个孤岛上

3. $$
   \sum_{i=1}^{n}i^{1}=\cfrac{n(n+1)}{2}=\cfrac{1}{2}n^{2}+\cfrac{1}{2}n
   $$

4. $$
   \sum_{i=1}^{n}i^{2}=\cfrac{n(n+1)(2n+1)}{6}=\cfrac{1}{3}n^{3}+\cfrac{1}{2}n^{2}+\cfrac{1}{6}n
   $$

5. $$
   \sum_{i=1}^{n}i^{3}=(\cfrac{n\cdot(n+1)}{2})^{2}=\cfrac{1}{4}n^{4}+\cfrac{1}{2}n^{3}+\cfrac{1}{4}n^{2}
   $$

6. $$
   \sum_{i=1}^{n}i^{4}=\cfrac{n(n+1)(2n+1)(3n^{2}+3n-1)}{30}=\cfrac{1}{5}n^{5}+\cfrac{1}{2}n^{4}+\cfrac{1}{3}n^{3}-\cfrac{1}{30}n
   $$

   

7. $$
   \sum_{i=1}^{n}i^{5}=\cfrac{n^{2}(n+1)^{2}(2n^{2}+2n-1)}{12}=\cfrac{1}{6}n^{6}+\cfrac{1}{2}n^{5}+\cfrac{5}{12}n^{4}-\cfrac{1}{12}n^{2}
   $$

   
   
9. ![特殊数列求和](/Users/davidxu/Desktop/算法笔记md/math_pic/有用的小结论/特殊数列求和.png)

10. n^2枚举一组数据的差值。有个性质。a2-a1已知,a3-a2已知，是可以线性组合成a3-a1的，也就是说只要O(n)，可以得到组成n^2所有差的原材料。那么如果能被这(n-1)线性组合出来，那么其最终反应形态就是∑{j,k}(aj−ak),只不过前面系数有0有其他值，各不相同。

11. <img src="/Users/davidxu/Desktop/算法笔记md/math_pic/有用的小结论/球冠公式.png" alt="球冠公式" style="zoom:50%;" />

12. 圆交

    ```c++
    struct Circle 
    {
        double x, y, r;
        Circle(double x = 0.0, double y = 0.0, double r = 0.0) :x(x), y(y), r(r) {}
        double area() const {
            return pi * sq(r);
        }
    };
    
    double calarea(Circle c1, Circle c2) {
        double dis = sqrt((c1.x - c2.x) * (c1.x - c2.x) + (c1.y - c2.y) * (c1.y - c2.y));
        if (c1.r + c2.r <= dis)
            return 0;
        if (c1.r - c2.r >= dis)
            return acos(-1.0) * c2.r * c2.r;
        if (c2.r - c1.r >= dis)
            return acos(-1.0) * c1.r * c1.r;
        double angle1 = acos((c1.r * c1.r + dis * dis - c2.r * c2.r) / (2 * dis * c1.r));
        double angle2 = acos((c2.r * c2.r + dis * dis - c1.r * c1.r) / (2 * dis * c2.r));
        return c1.r * c1.r * angle1 + c2.r * c2.r * angle2 - sin(angle1) * c1.r * dis;
    }
    ```

12. 叉积的运用（此处在之后的凸包和极角排序会用用到）： 
    a×b>0 则说明 b在a的左上方 
    a×b<0 则说明b在a的右下方 
    例如： a=（x1,y1）,b=(x2,y2) 
    则 a×b=x1\*y2-x2\*y1;

13. gcd(i,n)=gcd(n-i,n)


14. a\*b=gcd(a,b)\*lcm(a,b)

15. gcd(i,n)=d的个数有φ(n/d)（欧拉函数）

16. 定义d(n)为n的约数个数

$$
d(i\cdot j)=\sum_{x|i}\sum_{y|j}[\ gcd(x,y)=1\ ]
$$

17.$\sum_{i=1}^{x} C_{x}^{i}\cdot C_{y}^{i}=\sum_{i=1}^{x} C_{x}^{x-i}\cdot C_{y}^{i}=C_{x+y}^{x}$

```
ΣC(x,i)*C(y,i) = ΣC(x,x-i)*C(y,i) = C(x+y,x)
```

18. ![二角和差](/Users/davidxu/Desktop/算法笔记md/math_pic/二角和差.png)

19. <img src="/Users/davidxu/Desktop/算法笔记md/math_pic/半角公式.png" alt="半角公式" style="zoom:60%;" />

20. <img src="/Users/davidxu/Desktop/算法笔记md/math_pic/万能公式.png" alt="万能公式" style="zoom:60%;" />

21. <img src="/Users/davidxu/Desktop/算法笔记md/math_pic/万能公式.png" alt="万能公式" style="zoom:67%;" />

22. ![和差化积](/Users/davidxu/Desktop/算法笔记md/math_pic/和差化积.png)

23. ![正弦定理和余弦定理](/Users/davidxu/Desktop/算法笔记md/math_pic/正弦定理和余弦定理.png)

24. <img src="/Users/davidxu/Desktop/算法笔记md/math_pic/泰勒展开.png" alt="泰勒展开" style="zoom:67%;" />

25.

```c++
struct point3 {
    double x, y, z;
    point3(double a = 0, double b = 0, double c = 0) :x(a), y(b), z(c)
    {}
};
int n;

//求三维空间上一点q绕 向量（x0,y0,z0）正向旋转ang 弧度的点，向量起点在原点
point3 rotate3(point3 q, double x0, double y0, double z0, double ang)
{
    double x2 = x0 * x0;
    double y2 = y0 * y0;
    double z2 = z0 * z0;
    double d2 = x2 + y2 + z2;
    double d = sqrt(d2);
    double sina = sin(ang);
    double cosa = cos(ang);
    point3 ans;
    ans.x = (x2 + (y2 + z2) * cosa) / d2 * q.x
        + (x0 * y0 * (1 - cosa) / d2 - z0 * sina / d) * q.y
        + (x0 * z0 * (1 - cosa) / d2 + y0 * sina / d) * q.z;
    ans.y = (y0 * x0 * (1 - cosa) / d2 + z0 * sina / d) * q.x
        + (y2 + (x2 + z2) * cosa) / d2 * q.y
        + (y0 * z0 * (1 - cosa) / d2 - x0 * sina / d) * q.z;
    ans.z = (z0 * x0 * (1 - cosa) / d2 - y0 * sina / d) * q.x
        + (z0 * y0 * (1 - cosa) / d2 + x0 * sina / d) * q.y
        + (z2 + (x2 + y2) * cosa) / d2 * q.z;
    return ans;
}
```



26. 二项式展开式中奇数项系数之和等于偶数项系数之和，为$2^{n-1}$
26. 海伦公式

$$
S=\sqrt{p(p-a)(p-b)(p-c)}
$$



