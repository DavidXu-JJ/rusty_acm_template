[TOC]

<div STYLE="page-break-after: always;"></div>

# å›¾è®ºæ¨¡æ¿

##  å¹¶æŸ¥é›†æ“ä½œ

```c++
int father[1001];
//å¹¶æŸ¥é›†æ‰¾çˆ¶äº²çš„æ“ä½œ
int findFather(int x){
    while(x!=father[x]){
        x = father[x];
    }
    return x;
}
//æ›´æ–°çš„å¹¶æŸ¥é›†æŸ¥æ‰¾
int find(int x)
{
    if(x==fa[x])
        return x;
    return fa[x]=find(fa[x]);
}
//å¹¶æŸ¥é›†åˆå¹¶çš„æ“ä½œ
void Union(int a, int b){
    int af = findFather(a);
    int bf = findFather(b);
    father[bf] = af;
}
```
## bitsetæ±‚å¯è¾¾æ€§

Oï¼ˆn<sup>2</sup>/64ï¼‰

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stack>
#include<vector>
#include<cstdio>
#include<bitset>
#define ll long long
using namespace std;
const int maxn=2e3+10;
bitset<maxn> f[maxn];	//ç›¸å½“äºé‚»æ¥çŸ©é˜µå­˜
int ans;
char s[maxn];
int main()
{
	int n;
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
		scanf("%s",s);
		for(int j=1;j<=n;j++)
		{
			if(s[j-1]=='1'||i==j)
				f[i][j]=1;
		}
	}
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
	{
		if(f[j].test(i))
			f[j]|=f[i];
		//å¦‚æœjå¯ä»¥åˆ°è¾¾i,é‚£ä¹ˆç‚¹ièƒ½åˆ°çš„ç‚¹è‚¯å®šèƒ½è¢«ç‚¹jæ‰€è¾¾åˆ°
	}
	ll ans=0;
	for(register int i=1;i<=n;i++)
		ans+=f[i].count();
	cout<<ans;
}
```

<div STYLE="page-break-after: always;"></div>

## æœ€å°ç”Ÿæˆæ ‘

### Kruskal	O(elog(e))

ä¸ºå®Œå…¨å›¾æ—¶ï¼Œè¾¹æ•°æœ‰n<sup>2</sup>ä¸ªï¼Œå¤æ‚åº¦ä¸ºO(n<sup>2</sup>logn)

```c++
int n,r;
int fa[maxn];
int find(int x)
{
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void merge(int a,int b)
{
	fa[find(a)]=find(b);
}

struct edge{
	int u,v,w;
}all[maxn*maxn];

bool cmp(edge a ,edge b)
{
	return a.w<b.w;
}

int Kruskal()
{
	int ans=0;
	cin>>n>>r;	//ç‚¹æ•°å’Œè¾¹æ•°
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=r;i++)
		cin>>all[i].u>>all[i].v>>all[i].w;
	sort(all+1,all+1+r,cmp);
	int now=1;
	for(int _=1;_<=n-1;_++){	//åªéœ€é€‰n-1æ¡è¾¹
		while(find(all[now].u)==find(all[now].v))now++;
		ans+=all[now].w;
		merge(all[now].u,all[now].v);
	}
	return ans;
}
```



## æœ€çŸ­è·¯

###  Dijkstra	

O(n<sup>2</sup>+e)ï¼ˆéœ€è¦æ‰€æœ‰è¾¹å‡ä¸ºæ­£æƒï¼‰

```c++
const int N=110;
const int INF=0x3f3f3f3f;
int Map[N][N];	//é‚»æ¥çŸ©é˜µå­˜å‚¨,éœ€è¦å°†ä¸é€šçš„è·¯ç½®ä¸ºINF(!!!éœ€è¦åˆå§‹åŒ–ä¸ºINF)
bool vis[N];
int dj[N];
void Dijkstra()	//æœ‰æš‡ç–µ,ä»…è®¡ç®—ä»0ç‚¹å‡ºå‘çš„æœ€çŸ­è·¯å¾„é•¿,æœ€ç»ˆç»“æœä¿å­˜äºdjæ•°ç»„
{
    memset(vis,0,sizeof(vis));
    for(int i=0;i<=n;++i)
        dj[i] = Map[0][i];
    vis[0] = 1;
    for(int i=1;i<=n;++i)
    {
        int mindj = INF;
        int pos;
        for(int j=1;j<=n;++j)
        {
            if(dj[j]<mindj&&!vis[j])
            {
                mindj = dj[j];
                pos = j;
            }
        }
        vis[pos] = 1;
        for(int j=1;j<=n;++j)
        {
            if(!vis[j] && dj[j] > dj[pos] + Map[pos][j])
                dj[j] = dj[pos] + Map[pos][j];
        }
    }
}
```
### å †ä¼˜åŒ–Dijkstra	

O(E*log(V))

```c++
//å †ä¼˜åŒ–ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ— å¤æ‚åº¦O(E*log(E))
#include<iostream>
#include<vector>
#include<queue>
#include<cstdio>
#include<cstring>
#define ll long long
const ll N=110;
const ll inf=0x3f3f3f3f;
using namespace std;
struct node
{
    ll to,w;
    bool operator <(const node & a) const {return w>a.w;}  
    //ä¼˜å…ˆé˜Ÿåˆ—é»˜è®¤æŒ‰é™åºæ’åˆ—ï¼Œå› æ­¤è¦ä½¿å°æƒé‡è·¯çº¿çš„ä¼˜å…ˆçº§é«˜
};
vector<node> adja[N];	//é‚»æ¥è¡¨å­˜å‚¨ï¼Œæ³¨æ„å­˜å‚¨å•å‘è¾¹è¿˜æ˜¯åŒå‘è¾¹
bool vis[N];
ll dis[N];
ll Dijkstra(ll start,ll end)
{
    memset(vis, false, sizeof(vis));
    for(ll i=0;i<N;i++)
    {
        dis[i]=inf;
    }
    priority_queue<node> q;
    dis[start]=0;
    q.push({start,0});
    while(!q.empty())
    {
        node now=q.top();
        q.pop();
        ll mid=now.to;
        if(vis[mid])
            continue;
        vis[mid]=true;
        ll len=adja[mid].size();
        for(ll i=0;i<len;i++)
        {
            node tar=adja[mid][i];
            ll ter=tar.to;
            ll cost=tar.w;
            if(!vis[ter]&&dis[ter]>dis[mid]+cost)
            {
                dis[ter]=dis[mid]+cost;
                q.push({ter,dis[ter]});
            }
        }
    }
    return dis[end];
}

```
### Bellman-Ford	ï¼ˆO(V*E)ï¼‰ï¼ˆå¯ä»¥å¤„ç†è´Ÿæƒï¼Œä½†ä¸èƒ½æœ‰è´Ÿæƒå›è·¯ï¼‰

```c++
#include<cstring>
#define ll long long
const ll N=110,M=10010;
const ll inf=0x3f3f3f3f;
using namespace std;
struct Edge
{
    ll from,to,weight;
}E[M];  //ä½ç½®0ä¸ä½¿ç”¨
ll dis[N];
ll nodenum,edgenum;
void init(ll start)
{
    for(int i=1;i<=nodenum;i++)
    {
        dis[i]=inf;
    }
    for(ll i=1;i<=edgenum;i++)   //è¯¥å¤„åˆå§‹åŒ–ä¾ç…§æƒ…å†µï¼Œå¯è°ƒæ•´è‡³è¾“å…¥æ—¶åˆå§‹åŒ–
    {
        if(E[i].from==start)
            dis[E[i].to]=E[i].weight;
    }
    dis[start]=0;
}
void relax(ll from,ll to,ll weight)
{
    if(dis[to]>dis[from]+weight)
        dis[to]=dis[from]+weight;
}
ll bellman_ford(ll start,ll end)
{
    init(start);
    for(ll i=1;i<nodenum;i++)   //V-1æ¬¡
    for(ll j=1;j<=edgenum;j++)
    {
        relax(E[j].from,E[j].to,E[j].weight);
    }
    for(ll i=1;i<=edgenum;i++)
    {
        if(dis[E[i].to]>dis[E[i].from]+E[i].weight)
            return -1;
    }
    return dis[end];
}
```
### SPFAé“¾å¼å‰å‘æ˜Ÿ(å¯èƒ½è¢«å¡æ—¶é•¿)

```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
#include <queue>
#include <cmath>
#define LL long long
using namespace std;

const int N=1e6+100;
const LL M=(1<<31)-1,MM=0x3f;
struct sb
{
	int uu,ww,to,next;
}a[N];	//æ•°ç»„çš„å¤§å°éœ€è¦å¼€2*N
int u,v,w,n,m,s,t,tot,f[N],dis[N],last[N];
queue <int> q;
void add (int u,int v,int w)
{
	a[++tot].ww=w;
	a[tot].to=v;
	a[tot].next=last[u];
	last[u]=tot;
}
void spfa ()
{
    memset (dis,0x3f,sizeof (dis));
    dis[s]=0;
    q.push (s);
	while (!q.empty ())
	{
		int h=q.front ();
		q.pop ();
		for (int i=last[h];i;i=a[i].next)
		{
			int fg=a[i].to; 
			if (dis[fg]>dis[h]+a[i].ww)
			{
				dis[fg]=dis[h]+a[i].ww;
				q.push (fg);
			}
		}
	}
}

int main ()
{
	scanf ("%d %d %d",&m,&n,&s);
	for (int i=1;i<=n;i++) scanf ("%d %d %d",&u,&v,&w),add (u,v,w);//add (v,u,w);
	spfa ();
	for (int i=1;i<=m;i++)
	{
		if (dis[i]>N) printf ("%d ",M);
		else printf ("%d ",dis[i]);
	}
	return 0;
}
```
###  Floyd	ï¼ˆéœ€è¦æ²¡æœ‰æƒå€¼å°äº0çš„å›è·¯ï¼‰

```c++
#include <stdio.h>
#define inf 0x3f3f3f3f
int map[1000][1000];		//é‚»æ¥çŸ©é˜µ
int main()
{
    int k,i,j,n,m;
    //è¯»å…¥nå’Œmï¼Œnè¡¨ç¤ºé¡¶ç‚¹ä¸ªæ•°ï¼Œmè¡¨ç¤ºè¾¹çš„æ¡æ•°
    scanf("%d %d",&n,&m);

    //åˆå§‹åŒ–
    for(i=1; i<=n; i++)
        for(j=1; j<=n; j++)
            if(i==j)
                map[i][j]=0;
            else
                map[i][j]=inf;
    int a,b,c;
    //è¯»å…¥è¾¹
    for(i=1; i<=m; i++)
    {
        scanf("%d %d %d",&a,&b,&c);
        map[a][b]=c;//è¿™æ˜¯ä¸€ä¸ªæœ‰å‘å›¾
    }

    //Floyd-Warshallç®—æ³•æ ¸å¿ƒè¯­å¥
    for(k=1; k<=n; k++)
        for(i=1; i<=n; i++)
            for(j=1; j<=n; j++)
                if(map[i][j]>map[i][k]+map[k][j] )
                    map[i][j]=map[i][k]+map[k][j];

    //è¾“å‡ºæœ€ç»ˆçš„ç»“æœ,æœ€ç»ˆäºŒç»´æ•°ç»„ä¸­å­˜çš„å³ä½¿ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»
    for(i=1; i<=n; i++)
    {
        for(j=1; j<=n; j++)
        {
            printf("%10d",map[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

<div STYLE="page-break-after: always;"></div>

## å›¾çš„è¿é€šæ€§
### æ±‚è”é€šåˆ†æ”¯æ•°(Tarjanç®—æ³•)	[é“¾æ¥](https://www.youtube.com/watch?v=TyWtx7q2D7Y)
[é¢˜ç›®ä¼ é€é—¨](https://www.luogu.com.cn/problem/P7251)ï¼ˆæ ·ä¾‹æ•°æ®æ˜¯é”™çš„ï¼‰

> å…¶ä»–è¦ç‚¹ï¼šæ·»åŠ æœ€å°‘çš„è¾¹ä½¿å›¾å˜æˆå¼ºè”é€šï¼Œ

>è¾¹æ•°=å¼ºè”é€šåˆ†é‡ç¼©ç‚¹åå‡ºåº¦ä¸º0çš„ç‚¹æ•°ä¸å…¥è¯»ä¸º0çš„ç‚¹æ•°çš„è¾ƒå¤§å€¼

>ä¸€ä¸ªå‡ºåº¦ä¸º0çš„ç‚¹å’Œå…¥åº¦ä¸º0çš„ç‚¹ä¹‹é—´ä¸€å®šèƒ½æ·»åŠ ä¸€æ¡è¾¹ï¼Œä½¿è¿™ä¸¤ä¸ªç‚¹è”é€š

>å³ä¸€ä¸ªå‡ºåº¦ä¸º0çš„ç‚¹å’Œå…¥åº¦ä¸º0çš„ç‚¹èƒ½ç›¸æ¶ˆï¼Œç›¸æ¶ˆåå¤šå‡ºæ¥çš„é‚£éƒ¨åˆ†ç‚¹ä¸è”é€šï¼Œå› æ­¤å¾—å†å¤šåŠ è¾¹ï¼Œä½¿è¿™äº›ç‚¹ä¸å…¶ä»–ç‚¹è”é€š


```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stack>
#include<vector>
using namespace std;
const int maxn=3e5+10;
vector<int> G[maxn];
stack<int> s;
int n,sum;
int tot;
bool on_stack[maxn];		//åˆ¤æ–­æ˜¯å¦åœ¨æ ˆ
int dfn[maxn],low_link[maxn];
int sz[maxn],belong[maxn];	//szä¸ºè”é€šåˆ†æ”¯çš„ç‚¹ä¸ªæ•°ï¼Œbelongä¸ºnå·ç‚¹å½’å±äºå“ªä¸ªè”é€šåˆ†æ”¯
int out[maxn],in[maxn];		//ç»Ÿè®¡è”é€šåˆ†æ”¯ç¼©ç‚¹åçš„å…¥åº¦å’Œå‡ºåº¦
void tarjan(int u)
{
	dfn[u]=low_link[u]=++sum;
	s.push(u);
	on_stack[u]=1;
	int len=G[u].size();
	for(int i=0;i<len;i++)
	{
		int v=G[u][i];
		if(!dfn[v])
		{
			tarjan(v);
			low_link[u]=min(low_link[v],low_link[u]);
		}
		else if(on_stack[v])
		{
			low_link[u]=min(low_link[v],low_link[u]);
		}
	}
	if(low_link[u]==dfn[u])
	{
		int y=-99999;
		tot++;
		do
		{
			y=s.top();
			s.pop();
			belong[y]=tot;
			sz[tot]++;
			on_stack[y]=0;
		}while(y!=u);
	}
}
pair<int,int> E[maxn];
int main()
{
	int m;
	cin>>n>>m;
	for(int i=0;i<m;i++)
	{
		int from,to;
		cin>>from>>to;
		G[from].push_back(to);
		E[i]=make_pair(from, to);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])			//éå†å›¾ï¼Œä¿è¯æ¯ä¸ªè”é€šåˆ†æ”¯éƒ½dfsåˆ°
			tarjan(i);
	for(int i=0;i<m;i++)
	{
			int bu=belong[E[i].first],bv=belong[E[i].second];
			if(bu!=bv)
			{
				out[bu]++;
				in[bv]++;
			}
	}
	int ans1=0,ans2=0;
	for(int i=1;i<=tot;i++)
	{
		if(!in[i]) ans1++;
		if(!out[i]) ans2++;
	}
	cout<<*max_element(sz+1,sz+tot+1)<<'\n'<<max(ans1,ans2);
}
```
### ï¼ˆé“¾å¼å‰å‘æ˜Ÿç‰ˆï¼‰

```c++
#include<cstdio>
#include<cstring>
#include<iostream>  
#include<algorithm>
using namespace std;
#define M 500010
inline int Readint(void){
	int s=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){s=s*10+c-48;c=getchar();}
	return s*f;
}
struct Node{
	int nex,u,v,w;
}Edge[M];
int n,m,u,v;
int head[M],cnt;
int stack[M],top;
int belong[M],idx,size[M];
int dfn[M],low[M],tot;
int in[M],out[M];
int Max,ans1,ans2;
void addEdge(int u,int v,int w){
	Edge[++cnt]=(Node){head[u],u,v,w};
	head[u]=cnt;
	return;
}
void Tarjan(int u){
	dfn[u]=low[u]=++tot;
	stack[++top]=u;
	for(int i=head[u];i;i=Edge[i].nex){
		int v=Edge[i].v;
		if(!dfn[v]){
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!belong[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		idx++;
		while(stack[top+1]!=u){
			int v=stack[top--];
			belong[v]=idx;
			size[idx]++;
			Max=max(Max,size[idx]);
		}
	}
	return;
}
signed main(void){
	n=Readint();m=Readint();
	for(int i=1;i<=m;i++){
		u=Readint();v=Readint();
		addEdge(u,v,1);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])
			Tarjan(i);
	printf("%d\n",Max);
	for(int i=1;i<=m;i++){
		int Bu=belong[Edge[i].u],Bv=belong[Edge[i].v];
		if(Bu!=Bv){
			out[Bu]++;
			in[Bv]++;
		}
	}
	for(int i=1;i<=idx;i++){
		if(!in[i]) ans1++;
		if(!out[i]) ans2++;
	}
	printf("%d\n",max(ans1,ans2));
	return 0;
}
```
<div STYLE="page-break-after: always;"></div>

##  æœ€çŸ­è·¯ä¸è”é€šæ€§ç»“åˆ

**é¢˜ç›®æè¿°**	[é“¾æ¥](https://www.luogu.com.cn/problem/P2656)

å°èƒ–å’ŒZYRè¦å»ESQMSæ£®æ—é‡‡è˜‘è‡ã€‚

ESQMSæ£®æ—é—´æœ‰Nä¸ªå°æ ‘ä¸›ï¼ŒMæ¡å°å¾„ï¼Œæ¯æ¡å°å¾„éƒ½æ˜¯å•å‘çš„ï¼Œè¿æ¥ä¸¤ä¸ªå°æ ‘ä¸›ï¼Œä¸Šé¢éƒ½æœ‰ä¸€å®šæ•°é‡çš„è˜‘è‡ã€‚å°èƒ–å’ŒZYRç»è¿‡æŸæ¡å°å¾„ä¸€æ¬¡ï¼Œå¯ä»¥é‡‡èµ°è¿™æ¡è·¯ä¸Šæ‰€æœ‰çš„è˜‘è‡ã€‚ç”±äºESQMSæ£®æ—æ˜¯ä¸€ç‰‡ç¥å¥‡çš„æ²ƒåœŸï¼Œæ‰€ä»¥ä¸€æ¡è·¯ä¸Šçš„è˜‘è‡è¢«é‡‡è¿‡åï¼Œåˆä¼šé•¿å‡ºä¸€äº›æ–°çš„è˜‘è‡ï¼Œæ•°é‡ä¸ºåŸæ¥è˜‘è‡çš„æ•°é‡ä¹˜ä¸Šè¿™æ¡è·¯çš„â€œæ¢å¤ç³»æ•°â€ï¼Œå†ä¸‹å–æ•´ã€‚

æ¯”å¦‚ï¼Œä¸€æ¡è·¯ä¸Šæœ‰4ä¸ªè˜‘è‡ï¼Œè¿™æ¡è·¯çš„â€œæ¢å¤ç³»æ•°â€ä¸º0.7ï¼Œåˆ™ç¬¬ä¸€~å››æ¬¡ç»è¿‡è¿™æ¡è·¯å¾„æ‰€èƒ½é‡‡åˆ°çš„è˜‘è‡æ•°é‡åˆ†åˆ«ä¸º4,2,1,0.

ç°åœ¨ï¼Œå°èƒ–å’ŒZYRä»Så·å°æ ‘ä¸›å‡ºå‘ï¼Œæ±‚ä»–ä»¬æœ€å¤šèƒ½é‡‡åˆ°å¤šå°‘è˜‘è‡ã€‚

å¯¹äº30%çš„æ•°æ®ï¼ŒN<=7ï¼ŒM<=15

å¦æœ‰30%çš„æ•°æ®ï¼Œæ»¡è¶³æ‰€æœ‰â€œæ¢å¤ç³»æ•°â€ä¸º0

å¯¹äº100%çš„æ•°æ®ï¼ŒN<=80,000ï¼ŒM<=200,000ï¼Œ0.1<=æ¢å¤ç³»æ•°<=0.8ä¸”ä»…æœ‰ä¸€ä½å°æ•°ï¼Œ1<=S<=N.

**è¾“å…¥æ ¼å¼**

ç¬¬ä¸€è¡Œï¼ŒNå’ŒM

ç¬¬2â€¦â€¦M+1è¡Œï¼Œæ¯è¡Œ4ä¸ªæ•°å­—ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸€æ¡å°è·¯çš„èµ·ç‚¹ï¼Œç»ˆç‚¹ï¼Œåˆå§‹è˜‘è‡æ•°ï¼Œæ¢å¤ç³»æ•°ã€‚

ç¬¬M+2è¡Œï¼Œä¸€ä¸ªæ•°å­—S

**è¾“å‡ºæ ¼å¼**

ä¸€ä¸ªæ•°å­—ï¼Œè¡¨ç¤ºæœ€å¤šèƒ½é‡‡åˆ°å¤šå°‘è˜‘è‡ï¼Œåœ¨int32èŒƒå›´å†…ã€‚

**åšæ³•å…¶ä¸€**	ï¼ˆTarjanç¼©ç‚¹+SPFAæ±‚æœ€é•¿è·¯ï¼‰

>è¾¹æƒä¹˜-1åè·‘SPFAæ±‚æœ€çŸ­è·¯ï¼Œæœ€ç»ˆç»“æœå†ä¹˜-1å¯å¾—æœ€é•¿è·¯

```c++
#include<iostream>
#include<vector>
#include<queue>
#define ll long long
using namespace std;
const int maxn=2e5+10;
const int inf=0x3f3f3f3f;
struct edge
{
	int u,v,w,nex;
}E[maxn],E2[maxn];
int cnt,cnt2,head[maxn],head2[maxn];
void add(int u,int v,int w)
{
	E[++cnt]={u,v,w,head[u]};
	head[u]=cnt;
	return;
}
void add2(int u,int v,int w)
{
	E2[++cnt2]={u,v,w,head2[u]};
	head2[u]=cnt2;
	return;
}

int dfn[maxn],low[maxn],top,stack[maxn],tot;
int belong[maxn],idx,size[maxn];
void Tarjan(int u){
	dfn[u]=low[u]=++tot;
	stack[++top]=u;
	for(int i=head[u];i;i=E[i].nex){
		int v=E[i].v;
		if(!dfn[v]){
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!belong[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		idx++;
		while(stack[top+1]!=u){
			int v=stack[top--];
			belong[v]=idx;
			size[idx]++;
		}
	}
	return;
}

int dis[maxn];
bool vis[maxn];
double coef[maxn];

int ans=inf;
int	point[maxn];

int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int from,to,w;
		cin>>from>>to>>w>>coef[i];
		add(from,to,w);
	}
	int st;
	cin>>st;
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])
			Tarjan(i);
	}

	for(int i=1;i<=m;i++)
	{
		int bu=belong[E[i].u],bv=belong[E[i].v];
		if(bu==bv)
		{
			int num=E[i].w;
			while(num!=0)
			{
				point[bu]+=num;
				num=(int)(num*coef[i]);
			}
		}
	}
	
//		for(int i=1;i<=tot;i++)
//			cout<<belong[i]<<" ";
//		cout<<endl;
	
	for(int i=1;i<=m;i++)
		{
			int bu=belong[E[i].u],bv=belong[E[i].v];
			if(bu!=bv)
				{
					add2(bu,bv,-(point[bv]+E[i].w));
				}
		}


	for(int i=0;i<maxn;i++)
	{
		dis[i]=inf;
	}
	
	queue<int> q;
	q.push(belong[st]);
	dis[belong[st]]=-point[belong[st]];
	while (!q.empty()){
		int i=head2[q.front()];
		while (i){
			if (dis[E2[i].v]>dis[q.front()]+E2[i].w){
				dis[E2[i].v]=dis[q.front()]+E2[i].w;
				if (!vis[E2[i].v]){
					q.push(E2[i].v);
					vis[E2[i].v]=true;
				}
			}
			i=E2[i].nex;
		}
		vis[q.front()]=false;
		q.pop();
	}
	
	
	for(int i=1;i<=tot;i++)
	{
		if(dis[i]!=inf)
		ans=min(ans,dis[i]);
	}
	ans*=-1;
	cout<<ans;
}

```

<div STYLE="page-break-after: always;"></div>

## æ¬§æ‹‰å›è·¯


æ¬§æ‹‰å›è·¯ï¼šå›¾Gï¼Œè‹¥å­˜åœ¨ä¸€æ¡è·¯ï¼Œç»è¿‡Gä¸­æ¯æ¡è¾¹æœ‰ä¸”ä»…æœ‰ä¸€æ¬¡ï¼Œç§°è¿™æ¡è·¯ä¸ºæ¬§æ‹‰è·¯ï¼Œ

å¦‚æœå­˜åœ¨ä¸€æ¡å›è·¯ç»è¿‡Gæ¯æ¡è¾¹æœ‰ä¸”ä»…æœ‰ä¸€æ¬¡ï¼Œç§°è¿™æ¡å›è·¯ä¸ºæ¬§æ‹‰å›è·¯ã€‚å…·æœ‰æ¬§æ‹‰å›è·¯çš„å›¾æˆä¸ºæ¬§æ‹‰å›¾ã€‚

**åˆ¤æ–­æ¬§æ‹‰è·¯æ˜¯å¦å­˜åœ¨çš„æ–¹æ³•**

æœ‰å‘å›¾ï¼šå›¾è¿é€šï¼Œæœ‰ä¸€ä¸ªé¡¶ç‚¹å‡ºåº¦å¤§å…¥åº¦1ï¼Œæœ‰ä¸€ä¸ªé¡¶ç‚¹å…¥åº¦å¤§å‡ºåº¦1ï¼Œå…¶ä½™éƒ½æ˜¯å‡ºåº¦=å…¥åº¦ã€‚

æ— å‘å›¾ï¼šå›¾è¿é€šï¼Œåªæœ‰ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¥‡æ•°åº¦ï¼Œå…¶ä½™éƒ½æ˜¯å¶æ•°åº¦çš„ã€‚

**åˆ¤æ–­æ¬§æ‹‰å›è·¯æ˜¯å¦å­˜åœ¨çš„æ–¹æ³•**

æœ‰å‘å›¾ï¼šå›¾è¿é€šï¼Œæ‰€æœ‰çš„é¡¶ç‚¹å‡ºåº¦=å…¥åº¦ã€‚

æ— å‘å›¾ï¼šå›¾è¿é€šï¼Œæ‰€æœ‰é¡¶ç‚¹éƒ½æ˜¯å¶æ•°åº¦ã€‚

ï¼ˆä¸èƒ½æœ‰å¤šä¸ªè¿é€šåˆ†é‡ï¼Œä½†æ˜¯å­¤ç«‹ç‚¹å¯ä»¥æœ‰ï¼‰

```c++
//æ±‚æ¬§æ‹‰å›è·¯æˆ–æ¬§æ‹‰è·¯ï¼Œé‚»æ¥é˜µå½¢å¼ï¼Œå¤æ‚åº¦oï¼ˆn^2ï¼‰
//è¿”å›è·¯å¾„é•¿åº¦ï¼Œpathè¿”å›è·¯å¾„(æœ‰å‘å›¾æ˜¯å¾—åˆ°çš„æ˜¯åå‘è·¯å¾„)
//ä¼ å…¥å›¾çš„å¤§å°nå’Œé‚»æ¥é˜µmatï¼Œä¸ç›¸äº¤é‚»ç‚¹è¾¹æƒ0
//å¯ä»¥æœ‰è‡ªç¯ä¸é‡è¾¹ï¼Œåˆ†ä¸ºæ— å‘å›¾å’Œæœ‰å‘å›¾
#define MAXN 100 
//uä¸ºæ— å‘å›¾
void find_path_u(int n,int mat[][MAXN],int now,int& step,int* path){
ã€€ã€€int i; 
ã€€ã€€for (i=n-1;i>=0;i--) 
ã€€ã€€ã€€ã€€while (mat[now][i])ã€€ã€€ã€€ã€€{ 
   ã€€ã€€ mat[now][i]--,mat[i][now]--; 
   ã€€ã€€ find_path_u(n,mat,i,step,path); 
ã€€ã€€ã€€ã€€} 
ã€€ã€€path[step++]=now; 
}
//dä¸ºæœ‰å‘å›¾
void find_path_d(int n,int mat[][MAXN],int now,int& step,int* path){ 
ã€€ã€€int i; 
ã€€ã€€for (i=n-1;i>=0;i--) 
ã€€ã€€ã€€ã€€while (mat[now][i])ã€€ã€€ã€€ã€€{ 
   ã€€ã€€ mat[now][i]--; 
   ã€€ã€€ find_path_d(n,mat,i,step,path); 
ã€€ã€€ã€€ã€€} 
ã€€ã€€path[step++]=now; 
}
int euclid_path(int n,int mat[][MAXN],int start,int* path){ 
ã€€ã€€int ret=0; 
ã€€ã€€find_path_u(n,mat,start,ret,path); 
ã€€ã€€// find_path_d(n,mat,start,ret,path); 
ã€€ã€€return ret; 
}
```
### åˆ¤æ–­æ¬§æ‹‰å›è·¯æ¨¡æ¿é¢˜

```c++
//ç¡®å®šæ— å‘å›¾æ¬§æ‹‰å›è·¯çš„å……è¦æ¡ä»¶ï¼šé™¤å­¤ç«‹èŠ‚ç‚¹å¤–ï¼Œå…¶å®ƒèŠ‚ç‚¹æ»¡è¶³ 1.è¿é€š 2.åº¦ä¸ºå¶æ•°

#include <cstdio>
#include <algorithm>
 
using namespace std;
 
int father[1001];
//å¹¶æŸ¥é›†æ‰¾çˆ¶äº²çš„æ“ä½œ
int findFather(int x){
    while(x!=father[x]){
        x = father[x];
    }
    return x;
}
//å¹¶æŸ¥é›†åˆå¹¶çš„æ“ä½œ
void Union(int a, int b){
    int af = findFather(a);
    int bf = findFather(b);
    father[bf] = af;
}
 
int main(){
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF){
        int d[1001]; //èŠ‚ç‚¹åº¦
        fill(d,d+1001,0);
        for(int i=0;i<=n;i++) father[i]=i; //åˆå§‹åŒ–fatheræ•°ç»„
        for(int i=0;i<m;i++){
            int a,b;
            scanf("%d%d",&a,&b);
            d[a]++;
            d[b]++;
            Union(a,b);
        }
        int tmp=0;
        for(int i=1;i<=n;i++){
            //æœ‰å¥‡æ•°åº¦ï¼Œåº”æ‰“å°0
            if(d[i]%2!=0){
                tmp++;
                break;
            }
        }
        if(tmp>0){
            printf("0\n");
            continue;
        }
        int t = 1;
        for(int i=0;i<=n;i++){  //å¯»æ‰¾ä¸€ä¸ªéå­¤ç«‹èŠ‚ç‚¹ï¼Œå­˜å…¥t
            if(d[i]!=0){
                t = i;
                break;
            }
        }
        int f = findFather(t);
        bool flag = false;
        for(int i=2;i<=n;i++){
            //æ—¢ä¸æ˜¯å­¤ç«‹èŠ‚ç‚¹ï¼Œä¹Ÿä¸è¿é€šï¼Œåº”æ‰“å°0
            if(findFather(i)!=f && findFather(i)!=i){
                flag = true;
                break;
            }
        }
        if(flag){
            printf("0\n");
            continue;
        }
        if(n!=0){
            printf("1\n");
        }
         
    }
    return 0;
}
```

<div STYLE="page-break-after: always;"></div>

## äºŒåˆ†å›¾
### åˆ¤æ–­æ˜¯å¦æ˜¯äºŒåˆ†å›¾

```c++
#include<iostream>
#include<cmath>
#include<vector>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
vector<int> G[100];
int color[100];	//æŸ“è‰²bfs
bool bfs(int st)
{
    queue<int> q;
    q.push(st);
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        if(color[now]==1)
        {
            int len=G[now].size();
            for(int i=0;i<len;i++)
            {
                if(color[G[now][i]]==1)
                    return 0;
                if(!color[G[now][i]])
                {
                    color[G[now][i]]=2;
                    q.push(G[now][i]);
                    continue;
                }
            }
        }
        if(color[now]==2)
        {
            int len=G[now].size();
            for(int i=0;i<len;i++)
            {
                if(color[G[now][i]]==2)
                    return 0;
                if(!color[G[now][i]])
                {
                    color[G[now][i]]=1;
                    q.push(G[now][i]);
                    continue;
                }
            }
        }
        if(color[now]==0)
        {
            color[now]=1;
            q.push(now);
        }
    }
    return 1;
}
int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        memset(color,0,sizeof(color));
        for(int i=0;i<=n;i++)
        {
            G[i].clear();
        }
        for(int i=0;i<m;i++)
        {
            int to,from;
            cin>>to>>from;
            G[to].push_back(from);
            G[from].push_back(to);
        }
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            if(!bfs(i))
            {
                ans=1;
                break;
            }
        }
        if(ans)
        {
            cout<<"No\n";
        }
        else cout<<"Yes\n";
    }
}

```

<div STYLE="page-break-after: always;"></div>

### åŒˆç‰™åˆ©ç®—æ³•	O(V*E) 

```c++
#include<iostream>					//æœ€å°ç‚¹è¦†ç›–==æœ€å¤§åŒ¹é…
#include<cstring>					//æœ€å¤§ç‹¬ç«‹é›†==ç‚¹çš„æ€»æ•° - æœ€å°ç‚¹è¦†ç›–ã€‚
using namespace std;
const int maxn=510,maxm=510;		//å·¦å³ç‚¹é›†ä¸­ç‚¹çš„æ•°é‡
bool G[maxn][maxm];					//åªéœ€å»ºG[x][y]=1,ä»0å¼€å§‹å­˜
int x[maxn],y[maxm];
bool chk[maxm];
int SearchPath(int k)
{
    for(int i=0;i<maxm;i++)
    {
        if(G[k][i]&&!chk[i])
        {
            chk[i]=1;
            if(y[i]==-1||SearchPath(y[i]))
            {
                y[i]=k;
                x[k]=i;
                return 1;
            }
        }
    }
    return 0;
}
int hungarian()
{
    int ans=0;
    memset(x, -1, sizeof(x));
    memset(y, -1, sizeof(y));
    for(int i=0;i<maxn;i++)
    {
        memset(chk, false , sizeof(chk));
        ans+=SearchPath(i);
    }
    return ans;
}

```

### HKç®—æ³•	O(sqrt(V)*E)

```c++
#include<cstdio>
#include<cstring>
#include<queue>
#define INF 0x3f3f3f3f
using namespace std;

const int MAXN = 100+5;
const int MAXM = 300+5;

int p, n;
int a[MAXN][MAXM];

int dis;
int cx[MAXN], cy[MAXM];
int dx[MAXN], dy[MAXM];
bool vis[MAXM];

bool bfs_findPath() {
     queue<int> q;
     memset(dx, -1, sizeof(dx));
     memset(dy, -1, sizeof(dy));
     // ä½¿ç”¨BFSéå†å¯¹å›¾çš„ç‚¹è¿›è¡Œåˆ†å±‚ï¼Œä»Xä¸­æ‰¾å‡ºä¸€ä¸ªæœªåŒ¹é…ç‚¹v
     // (æ‰€æœ‰v)ç»„æˆç¬¬ä¸€å±‚ï¼Œæ¥ä¸‹æ¥çš„å±‚éƒ½æ˜¯è¿™æ ·å½¢æˆâ€”â€”æ¯æ¬¡æŸ¥æ‰¾
     // åŒ¹é…ç‚¹(å¢å¹¿è·¯æ€§è´¨)ï¼Œç›´åˆ°åœ¨Yä¸­æ‰¾åˆ°æœªåŒ¹é…ç‚¹æ‰åœæ­¢æŸ¥æ‰¾ï¼Œ
     // å¯¹Xå…¶ä»–æœªåŒ¹é…ç‚¹åŒæ ·è¿›è¡ŒæŸ¥æ‰¾å¢å¹¿è·¯å¾„(BFSåªåˆ†å±‚ä¸æ ‡è®°
     // æ˜¯å¦åŒ¹é…ç‚¹)
     // æ‰¾å‡ºXä¸­çš„æ‰€æœ‰æœªåŒ¹é…ç‚¹ç»„æˆBFSçš„ç¬¬ä¸€å±‚
     dis = INF;
     for(int i = 1; i <= p; ++i) {
         if(cx[i] == -1) {
             q.push(i);
             dx[i] = 0;
         }
     }
     while(!q.empty()) {
         int u = q.front();
         q.pop();
         if(dx[u] > dis) break;// è¯¥è·¯å¾„é•¿åº¦å¤§äºdisï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡BFSæ‰©å……
         for(int v = 1; v <= n; ++v) {
             if(a[u][v] && dy[v] == -1) {// (u,v)ä¹‹é—´æœ‰è¾¹ä¸”vè¿˜æ²¡æœ‰åˆ†å±‚
                 dy[v] = dx[u] + 1;
                 if(cy[v] == -1) dis = dy[v];// væ˜¯æœªåŒ¹é…ç‚¹ï¼Œåœæ­¢å»¶ä¼¸ï¼ˆæŸ¥æ‰¾ï¼‰,å¾—åˆ°æœ¬æ¬¡BFSçš„æœ€å¤§éå†å±‚æ¬¡
                 else {// væ˜¯å·²åŒ¹é…ç‚¹ï¼Œç»§ç»­å»¶ä¼¸
                     dx[cy[v]] = dy[v] + 1;
                     q.push(cy[v]);
                 }
             }
         }
     }
     return dis != INF;// è‹¥disä¸ºINFè¯´æ˜Yä¸­æ²¡æœ‰æœªåŒ¹é…ç‚¹ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å¢å¹¿è·¯å¾„äº†
 }

 bool dfs(int u) {
     for(int v = 1; v <= n; ++v) {
         if(!vis[v] && a[u][v] && dy[v] == dx[u] + 1) {
             vis[v] = 1;
             // å±‚æ¬¡ï¼ˆä¹Ÿå°±æ˜¯å¢å¹¿è·¯å¾„çš„é•¿åº¦ï¼‰å¤§äºæœ¬æ¬¡æŸ¥æ‰¾çš„dis
             // æ˜¯bfsä¸­è¢«breakçš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯è¿˜ä¸ç¡®å®šæ˜¯å¦æ˜¯å¢å¹¿è·¯
             // åªæœ‰ç­‰å†æ¬¡è°ƒç”¨bfså†åˆ¤æ–­(æ¯æ¬¡åªæ‰¾æœ€å°å¢å¹¿è·¯é›†)
             if(cy[v] != -1 && dy[v] == dis) continue;
             if(cy[v] == -1 || dfs(cy[v])) {// æ˜¯å¢å¹¿è·¯å¾„ï¼Œæ›´æ–°åŒ¹é…é›†
                 cy[v] = u;
                 cx[u] = v;
                 return true;
             }
         }
     }
     return false;
 }
 
 int HK() {
     int ans = 0;
     memset(cx, -1, sizeof(cx));
     memset(cy, -1, sizeof(cy));
     while(bfs_findPath()) {// æœ‰å¢å¹¿è·¯
         memset(vis, 0, sizeof(vis));
         for(int i = 1; i <= p; ++i) {
             // ç”¨DFSæŸ¥æ‰¾å¢å¹¿è·¯å¾„ï¼Œå¢å¹¿è·¯å¾„ä¸€å®šä»æœªåŒ¹é…ç‚¹å¼€å§‹
             // å¦‚æœæŸ¥æ‰¾åˆ°ä¸€ä¸ªå¢å¹¿è·¯å¾„ï¼ŒåŒ¹é…æ•°åŠ ä¸€
             if(cx[i] == -1 && dfs(i)) ++ans;
         }
     }
     return ans;
 }
 
 int main() {
     int T;
     scanf("%d", &T);
     while(T--) {
         scanf("%d%d", &p, &n);
         memset(a, 0, sizeof(a));
 
         for(int i = 1; i <= p; ++i) {
             int nm, x;
             scanf("%d", &nm);
             for(int j = 0; j != nm; ++j) {
                 scanf("%d", &x);
                 a[i][x] = 1;
             }
         }
         printf("%s\n", HK() == p ? "YES" : "NO");
     }
     return 0;
 }
```
###  KMç®—æ³•(äºŒåˆ†å›¾å¸¦æƒæœ€ä¼˜åŒ¹é…)(O(n^3))

```c++
//Data
const int N=500;
int n,m,e[N+7][N+7];

//KM
int mb[N+7],vb[N+7],ka[N+7],kb[N+7],p[N+7],c[N+7];
int qf,qb,q[N+7];
void Bfs(int u){
    int a,v=0,vl=0,d;
    for(int i=1;i<=n;i++) p[i]=0,c[i]=inf;
    mb[v]=u;
    do {
        a=mb[v],d=inf,vb[v]=1;
        for(int b=1;b<=n;b++)if(!vb[b]){
            if(c[b]>ka[a]+kb[b]-e[a][b])
                c[b]=ka[a]+kb[b]-e[a][b],p[b]=v;
            if(c[b]<d) d=c[b],vl=b;
        }
        for(int b=0;b<=n;b++)
            if(vb[b]) ka[mb[b]]-=d,kb[b]+=d;
            else c[b]-=d;
        v=vl;
    } while(mb[v]);
    while(v) mb[v]=mb[p[v]],v=p[v];
}
ll KM(){
    for(int i=1;i<=n;i++) mb[i]=ka[i]=kb[i]=0;
    for(int a=1;a<=n;a++){
    	for(int b=1;b<=n;b++) vb[b]=0;
		Bfs(a);
	}
	ll res=0;
	for(int b=1;b<=n;b++) res+=e[mb[b]][b];
	return res;
}

//Main
int main(){
	n=ri,m=ri;
	for(int a=1;a<=n;a++)
		for(int b=1;b<=n;b++) e[a][b]=-inf;
	for(int i=1;i<=m;i++){
		int u=ri,v=ri,w=ri;
		e[u][v]=max(e[u][v],w);
	}
	printf("%lld\n",KM());
	for(int u=1;u<=n;u++) printf("%d ",mb[u]);puts("");
	return 0;
}
```

ä»¥ä¸Šæ±‚çš„æ˜¯æœ€å¤§æƒå€¼åŒ¹é…

è‹¥è¦æ±‚æœ€å°æƒå€¼åŒ¹é…ï¼Œå¯ä»¥å»ºè´Ÿè¾¹ï¼Œç„¶åans= - KM();



<div STYLE="page-break-after: always;"></div>

## ç½‘ç»œæµ

### EKç®—æ³•ï¼ˆæœ€å¤šå¢å¹¿æ¬¡æ•°ä¸ºğ‘‚(ğ‘‰ğ¸)ï¼‰

```c++
#include <bits/stdc++.h>
//æœ€å¤§æµEKç®—æ³•ï¼šå¤æ‚åº¦:n*m^2(næ˜¯ç‚¹æ•°,mæ˜¯è¾¹æ•°)
//å¦‚æœé‡åˆ°ç¨ å¯†å›¾ç”¨Dinic
 
using namespace std;
const int maxn=220,inf=0x7f7f7f7f;
int g[maxn][maxn],flow[maxn],pre[maxn],n,m;
queue<int> q;
 
inline int bfs(int s,int t)
{
    while(!q.empty())q.pop();
    memset(pre,-1,sizeof(pre));
    pre[s]=0,flow[s]=inf;
    q.push(s);
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t)break;
        for(int u=1;u<=n;u++)
        {
            if(u!=s&&g[p][u]>0&&pre[u]==-1)
            {
                pre[u]=p;
                flow[u]=min(flow[p],g[p][u]);
                q.push(u);
            }
        }
    }
    if(pre[t]==-1)return -1;
    return flow[t];
}
 
inline int ek(int s,int t)
{
    int delta=0,tot=0;
    while(1)
    {
        delta=bfs(s,t);
        if(delta==-1)break;
        int p=t;
        while(p!=s)//æ›´æ–°å¢å¹¿è·¯
        {
            g[pre[p]][p]-=delta;
            g[p][pre[p]]+=delta;
            p=pre[p];
        }
        tot+=delta;
    }
    return tot;
}
 
int main()
{
    ios::sync_with_stdio(0);
    int u,v,w;
    scanf("%d %d",&m,&n);
    memset(g,0,sizeof(g));
    memset(flow,0,sizeof(flow));
    for(int i=0;i<m;i++)
    {
        scanf("%d %d %d",&u,&v,&w);
        g[u][v]+=w;
    }
    printf("%d\n",ek(1,n));
    return 0;
}
 
/*
5 4
1 2 40
1 4 20
2 4 20
2 3 30
3 4 10
50
*/
```
### DINICç®—æ³•

```c++
#include <stdio.h>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#define maxn 10010
#define maxm 100010
#define inf 0x7fffffff

using namespace std;

int n,m,s,t;
int sum,ans;
int d[maxn];

struct edge{
    int to,val,rev; //revè¡¨ç¤ºåè¾¹åœ¨toçš„vectorå½“ä¸­ä¸‹æ ‡æ˜¯å‡ 
    edge (int _to,int _val,int _rev) //æ„é€ å‡½æ•°
    {
        to=_to;
        val=_val;
        rev=_rev;
    }
};

vector<edge> e[maxn];

void addedge(int x,int y,int w)
{
    e[x].push_back(edge(y,w,e[y].size()));
    e[y].push_back(edge(x,0,e[x].size()-1));
    /*
     æˆ–è€… ä¹Ÿå¯ä»¥è¿™æ ·å†™
     e[x].push_back((edge){y,w,e[y].size()});
     e[y].push_back((edge){x,0,e[x].size()-1});
    è¿™æ ·å†™ä¸éœ€è¦?çš„æ„é€ å‡½æ•°
     */
}

bool bfs()
{
    memset(d, -1, sizeof(d));
    queue<int> q;
    q.push(s);
    d[s]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<e[x].size();i++)
        {
            int y=e[x][i].to;
            if(d[y]==-1 && e[x][i].val)
            {
                q.push(y);
                d[y]=d[x]+1;
            }
        }
    }
    if(d[t]==-1)
        return 0;
    else
        return 1;
}

int dfs(int x,int low) //xè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œlowè¡¨ç¤ºå½“å‰æµåˆ°xçš„æ®‹é‡
{
    if(x==t || low==0)
        return low;
    int totflow=0; //totflowè¡¨ç¤ºxèŠ‚ç‚¹æ€»å…±æµå‡ºçš„æµé‡
    for(int i=0;i<e[x].size();i++)
    {
        int y=e[x][i].to;
        int rev=e[x][i].rev;
        if(d[y]==d[x]+1 && e[x][i].val) //yæ˜¯xçš„ä¸‹ä¸€å±‚ ä¸” å½“å‰è¾¹æœ‰æ®‹é‡>0
        {
            int a=dfs(y,min(low,e[x][i].val)); //aè¡¨ç¤ºå½“å‰è¾¹æµå‡ºçš„æµé‡
            e[x][i].val-=a;
            e[y][rev].val+=a;
            low-=a;
            totflow+=a;
            if(low==0) //æµåˆ°xçš„æµé‡æµå®Œäº†
                return totflow;
        }
    }
    if(low!=0) //ä¼˜åŒ–ï¼Œç›´è§‚ç†è§£ï¼šæµåˆ°xçš„æµé‡ä¼šæœ‰å†—ä½™ï¼Œè¿™ä¸€è½®dfsä¸­å°±å†ä¹Ÿä¸åˆ°xäº†
        d[x]=-1;
    return totflow;
}

void dinic()
{
    while(bfs())
        ans+=dfs(s,inf);
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++)
    {
        int x,y,w;
        scanf("%d%d%d",&x,&y,&w);
        addedge(x, y, w);
    }
    dinic();
    printf("%d\n",ans);
    return 0;
}
```

## å¸¦èŠ±æ ‘ O(n^3)

```c++
#include <bits/stdc++.h>
#ifndef ONLINE_JUDGE
#define debug(x) cout << #x << ": " << (x) << endl
#else
#define debug(x)
#endif
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int maxn=5e3+7,inf=0x3f3f3f3f,mod=1e9+7;

vector<int>G[maxn];
namespace Blossom
{ ///0~n-1
    const int N=1000+5;
    bool ban[N];
    int mate[N],n,ret;
    int nxt[N],dsu[N],mark[N],vis[N];
    queue<int> Q;
    int get(int x)
    {
        return (x==dsu[x]) ? x: (dsu[x]=get(dsu[x]));
    }
    void merge(int a,int b)
    {
        dsu[get(a)]=get(b);
    }
    int lca(int x,int y)
    {
        static int t=0;
        ++t;
        for(;;swap(x,y))
            if(x!=-1)
            {
                if(vis[x=get(x)]==t) return x;
                vis[x]=t;
                x=(mate[x]!=-1)?nxt[mate[x]]:-1;
            }
    }
    void group(int a,int p)
    {
        for(int b,c;a!=p;merge(a,b),merge(b,c),a=c)
        {
            b=mate[a],c=nxt[b];
            if(get(c)!=p)nxt[c]=b;
            if(mark[b]==2)mark[b]=1,Q.push(b);
            if(mark[c]==2)mark[c]=1,Q.push(c);
        }
    }
    void aug(int s,const vector<int> G[]) ///start from s ,do augment
    {
        for(int i=0;i<n;++i) nxt[i]=vis[i]=-1,dsu[i]=i,mark[i]=0;
        while(!Q.empty()) Q.pop();
        Q.push(s);
        mark[s]=1;
        while(mate[s]==-1 && !Q.empty())
        {
            int x=Q.front(); Q.pop();
            for(auto &y:G[x])
            if(!ban[y] && y!=mate[x]&& get(x)!=get(y) && mark[y]!=2)
            {
                if(mark[y]==1)
                {
                    int p=lca(x,y);
                    if(get(x)!=p) nxt[x]=y;
                    if(get(y)!=p) nxt[y]=x;
                    group(x,p),group(y,p);
                }
                else if(mate[y]==-1)
                {
                    nxt[y]=x;
                    for(int j=y,k,l;j!=-1;j=l) k=nxt[j],l=mate[k],mate[j]=k,mate[k]=j;
                    break;
                }
                else nxt[y]=x,Q.push(mate[y]),mark[mate[y]]=1,mark[y]=2;
            }
        }
    }
    int solve(int n,const vector<int> G[])
    {
        for(int i=0;i<n;++i) mate[i]=-1;
        for(int i=0;i<n;++i) if(mate[i]==-1) aug(i,G);
        int ans=0;
        for(int i=0;i<n;++i) if(mate[i]!=-1) ans++;
        return ans;
    }
};

int tot;
map<int,int>prime;
int getid(int x)
{
    if(x==1) return tot++;
    if(prime.count(x)) return prime[x];
    return prime[x]=tot++;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin>>n;
    for(int i=0,x;i<n;++i)
    {
        cin>>x;
        bool f=0;
        for(int j=2;j*j<=x;++j)
        {
            if(x%j==0)
            {
                int a=getid(j),b=getid(x/j);
                if(a==b) b=getid(1);
                G[a].push_back(b),G[b].push_back(a);
                f=1;
                break;
            }
        }
        if(!f)
        {
            int a=getid(x),b=getid(1);
            G[a].push_back(b),G[b].push_back(a);
        }
    }
    Blossom::n=tot;
    int res=Blossom::solve(tot,G)/2;
    cout<<res<<'\n';
    return 0;
}
```

## å·®åˆ†çº¦æŸ

ç»™å®šnä¸ªå˜é‡å’Œmä¸ªä¸ç­‰å¼ï¼Œæ¯ä¸ªä¸ç­‰å¼å½¢å¦‚ x[i] - x[j] <= a[k]ï¼Œæ±‚ x[n-1] - x[0] çš„æœ€å¤§å€¼ã€‚
(0 <= i, j < n)
ä¾‹ï¼šn=4
x1âˆ’x0<=2â‘ 
x2âˆ’x0<=7â‘¡
x3âˆ’x0<=8â‘¢
x2âˆ’x1<=3â‘£
x3âˆ’x2<=2â‘¤
ç„¶åç»è¿‡è®¤çœŸçš„çæè®¡ç®—å°±å˜æˆäº†è¿™ä¸ªé¸­å­ï¼š
1ã€â‘¢              x3âˆ’x0<=8
2ã€â‘¡+â‘¤         x3âˆ’x0<=9
3ã€â‘ +â‘£+â‘¤      x3âˆ’x0<=7

å¯¹äºæ¯ä¸ªä¸ç­‰å¼ xiâˆ’xj<=akï¼Œå¯¹ç»“ç‚¹ j å’Œ i å»ºç«‹ä¸€æ¡ jâˆ’>içš„æœ‰å‘è¾¹ï¼Œ
è¾¹æƒä¸ºakï¼Œæ±‚x<sub>nâˆ’1</sub>âˆ’x0 çš„æœ€å¤§å€¼å°±æ˜¯æ±‚ 0 åˆ°nâˆ’1çš„æœ€çŸ­è·¯ã€‚

å·®åˆ†çº¦æŸç³»ç»Ÿä¸­çš„æ¯ä¸ªçº¦æŸæ¡ä»¶ xi-xj<=ck éƒ½å¯ä»¥å˜å½¢æˆ xi<=xj+ck ï¼Œè¿™ä¸å•æºæœ€çŸ­è·¯ä¸­çš„ä¸‰è§’å½¢ä¸ç­‰å¼ dist[y]<=dist[x]+z (xä¸ºå‡ºå‘ç‚¹ï¼Œç»è¿‡zåˆ°è¾¾y)éå¸¸ç›¸ä¼¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ¯ä¸ªå˜é‡ xi çœ‹åšå›¾ä¸­çš„ä¸€ä¸ªç»“ç‚¹ï¼Œå¯¹äºæ¯ä¸ªçº¦æŸæ¡ä»¶ xi-xj<=ckï¼Œä»ç»“ç‚¹ j å‘ç»“ç‚¹ i è¿ä¸€æ¡é•¿åº¦ä¸º ck çš„**æœ‰å‘è¾¹**ã€‚

æ³¨æ„åˆ°ï¼Œå¦‚æœ {a1,a2,...,an} æ˜¯è¯¥å·®åˆ†çº¦æŸç³»ç»Ÿçš„ä¸€ç»„è§£ï¼Œé‚£ä¹ˆå¯¹äºä»»æ„çš„å¸¸æ•° d ï¼Œ{a1+d,a2+d,...,an+d} æ˜¾ç„¶ä¹Ÿæ˜¯è¯¥å·®åˆ†çº¦æŸç³»ç»Ÿçš„ä¸€ç»„è§£ï¼Œå› ä¸ºè¿™æ ·åšå·®å d åˆšå¥½è¢«æ¶ˆæ‰ã€‚

è®¾ dist[0]=0 å¹¶å‘æ¯ä¸€ä¸ªç‚¹è¿ä¸€æ¡æƒé‡ä¸º 0 è¾¹ï¼Œè·‘å•æºæœ€çŸ­è·¯ï¼Œè‹¥å›¾ä¸­å­˜åœ¨è´Ÿç¯ï¼Œåˆ™ç»™å®šçš„å·®åˆ†çº¦æŸç³»ç»Ÿæ— è§£ï¼Œå¦åˆ™ï¼Œxi=dist[i] ä¸ºè¯¥å·®åˆ†çº¦æŸç³»ç»Ÿçš„ä¸€ç»„è§£ã€‚

ä¸€èˆ¬ä½¿ç”¨ Bellman-Ford æˆ–é˜Ÿåˆ—ä¼˜åŒ–çš„ Bellman-Fordï¼ˆä¿—ç§° SPFAï¼Œåœ¨æŸäº›éšæœºå›¾è·‘å¾—å¾ˆå¿«ï¼‰åˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨è´Ÿç¯ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦ä¸º O(nm)ã€‚	ï¼ˆnä¸ªå˜é‡ï¼Œå³nä¸ªç‚¹ï¼Œmä¸ªçº¦æŸæ¡ä»¶ï¼Œå³mæ¡è¾¹ï¼‰



### æœ€å°å€¼é—®é¢˜

å¦‚æœæˆ‘ä»¬æŠŠä¸ç­‰å¼çš„ç¬¦å·æ”¹å˜ä¸€ä¸‹é‚£ä¹ˆæ±‚å¾—æœ€çŸ­è·¯é‚£ä¸å°±æ˜¯å˜æˆäº†æœ€é•¿è·¯é—®é¢˜å—ï¼Œ
é‚£ä¹ˆæˆ‘ä»¬åœ¨åšé¢˜çš„æ—¶å€™åªéœ€è¦æŠŠspfaä¸­çš„æ¾å¼›æ“ä½œçš„ç¬¦å·å˜ä¸€ä¸‹å°±è¡Œäº†....



### ä¸ç­‰å¼çš„æ ‡å‡†åŒ–

> 1.å¦‚æœç»™å‡ºçš„ä¸ç­‰å¼æœ‰"<="ä¹Ÿæœ‰">=" ï¼š

å¦‚æœéœ€è¦æ±‚çš„æ˜¯ä¸¤ä¸ªå˜é‡å·®çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆéœ€è¦å°†æ‰€æœ‰ä¸ç­‰å¼è½¬å˜æˆ"<="çš„å½¢å¼ï¼Œå»ºå›¾åæ±‚æœ€çŸ­è·¯ï¼›
ç›¸åï¼Œå¦‚æœéœ€è¦æ±‚çš„æ˜¯ä¸¤ä¸ªå˜é‡å·®çš„æœ€å°å€¼ï¼Œé‚£ä¹ˆéœ€è¦å°†æ‰€æœ‰ä¸ç­‰å¼è½¬åŒ–æˆ">="ï¼Œå»ºå›¾åæ±‚æœ€é•¿è·¯ã€‚

> 2.å¦‚æœæœ‰å½¢å¦‚ï¼šA - B = c è¿™æ ·çš„ç­‰å¼å‘¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥å°†å®ƒè½¬åŒ–æˆä»¥ä¸‹ä¸¤ä¸ªä¸ç­‰å¼ï¼š
Aâˆ’B>=c â‘ 
Aâˆ’B<=c â‘¡
å†é€šè¿‡ä¸Šé¢çš„æ–¹æ³•å°†å…¶ä¸­ä¸€ç§ä¸ç­‰å·åå‘ï¼Œå»ºå›¾å³å¯ã€‚

> 3.å¦‚æœè¿™äº›å˜é‡éƒ½æ˜¯æ•´æ•°åŸŸä¸Šçš„ï¼Œé‚£ä¹ˆé‡åˆ°A - B < cè¿™æ ·çš„ä¸å¸¦ç­‰å·çš„ä¸ç­‰å¼æ€ä¹ˆåŠå‘¢ï¼Ÿ

æˆ‘ä»¬å¯ä»¥å°†å®ƒè½¬åŒ–æˆ"<="æˆ–è€…">="çš„å½¢å¼ï¼Œå³ Aâˆ’B<=câˆ’1å½¢å¼å°±å¯ä»¥åšäº†...

[ä¾‹é¢˜](https://codeforces.ml/contest/1552/problem/D)

## å“ˆå¯†é¡¿å›è·¯

```c++
#include<stdio.h> 

#define V 5 

void printSolution(int path[]); 

/* A utility function to check if the vertex v can be added at 
   index 'pos' in the Hamiltonian Cycle constructed so far (stored 
   in 'path[]') 

ç”¨æ¥æ£€æµ‹å½“å‰é¡¶ç‚¹ä¸ªæ•°ä¸ºposï¼Œèµ°åˆ°é¡¶ç‚¹væ˜¯å¦å¯ä»¥åŠ å…¥å½“å‰å›è·¯ä¸­  
*/
bool isSafe(int v, bool graph[V][V], int path[], int pos) 
{ 
    /* Check if this vertex is an adjacent vertex of the previously 
       added vertex. 
       ä¸Šä¸€æ¬¡åŠ å…¥çš„é¡¶ç‚¹å’Œè¿™ä¸ªé¡¶ç‚¹væ˜¯å¦ç›¸è¿  
     */
    if (graph [ path[pos-1] ][ v ] == 0) 
        return false; 

    /* Check if the vertex has already been included. 
      This step can be optimized by creating an array of size V 
      åˆ¤æ–­é¡¶ç‚¹æ˜¯å¦å·²ç»åœ¨å›è·¯ä¸­ï¼Œè¿™é‡Œå¯ä»¥ç”¨ä¸€ä¸ªvisitedæ•°ç»„æ¥ä¼˜åŒ–ã€‚
      */
    for (int i = 0; i < pos; i++) 
        if (path[i] == v) 
            return false; 

    return true; 
} 

/* A recursive utility function to solve hamiltonian cycle problem 

*/
bool hamCycleUtil(bool graph[V][V], int path[], int pos) 
{ 
    /* base case: If all vertices are included in Hamiltonian Cycle 
    é¡¶ç‚¹æ•°å¤Ÿäº†
    */
    if (pos == V) 
    { 
        // And if there is an edge from the last included vertex to the 
        // first vertex 
        //çœ‹å›è·¯ç¬¬ä¸€ä¸ªé¡¶ç‚¹å’Œæœ€åä¸€ä¸ªé¡¶ç‚¹æ˜¯å¦ç›¸è¿ï¼Œç›¸è¿åˆ™æ»¡è¶³æ¡ä»¶
        if ( graph[ path[pos-1] ][ path[0] ] == 1 ) 
           return true; 
        else
          return false; 
    } 

    // Try different vertices as a next candidate in Hamiltonian Cycle. 
    // We don't try for 0 as we included 0 as starting point in in hamCycle() 

    //0ä½œä¸ºå›è·¯åˆå§‹é¡¶ç‚¹
    for (int v = 1; v < V; v++) 
    { 
        /* Check if this vertex can be added to Hamiltonian Cycle */

        //åˆ¤æ–­1åˆ°Vé¡¶ç‚¹æ˜¯å¦å¯ä»¥åŠ å…¥å›è·¯
        if (isSafe(v, graph, path, pos)) 
        { 
            path[pos] = v;  //å¯ä»¥ï¼Œå°±åŠ å…¥å›è·¯

            /* recur to construct rest of the path */
            if (hamCycleUtil (graph, path, pos+1) == true)  //é€’å½’å‰©ä¸‹çš„è·¯å¾„
                return true; 

            /* If adding vertex v doesn't lead to a solution, 
               then remove it 
                å¦‚æœé¡¶ç‚¹våŠ å…¥åä¸æ„æˆå›è·¯ï¼Œåˆ™å¼¹å‡ºæ¥ã€‚   
            */
            path[pos] = -1; 
        } 
    } 

    /* If no vertex can be added to Hamiltonian Cycle constructed so far, 
       then return false */
    return false; 
} 

/* This function solves the Hamiltonian Cycle problem using Backtracking. 
  It mainly uses hamCycleUtil() to solve the problem. It returns false 
  if there is no Hamiltonian Cycle possible, otherwise return true and 
  prints the path. Please note that there may be more than one solutions, 
  this function prints one of the feasible solutions. */

/*å›æº¯æ³•æ±‚æ±‰å¯†å°”é¡¿å›è·¯ï¼Œå¦‚æœä¸å­˜åœ¨è¿”å›falseï¼Œå¦‚æœå­˜åœ¨è¿”å›trueå¹¶æ‰“å°å›è·¯ï¼Œå¯èƒ½æœ‰å¤šé‡æ–¹æ¡ˆï¼Œåªæ‰“å°ä¸€ç§*/
bool hamCycle(bool graph[V][V]) 
{ 
    int *path = new int[V]; 
    for (int i = 0; i < V; i++) 
        path[i] = -1; //åˆå§‹åŒ–pathæ•°ç»„

    /* Let us put vertex 0 as the first vertex in the path. If there is 
       a Hamiltonian Cycle, then the path can be started from any point 
       of the cycle as the graph is undirected */
    path[0] = 0; //åŠ å…¥0å·é¡¶ç‚¹
    if ( hamCycleUtil(graph, path, 1) == false ) 
    { 
        printf("\nSolution does not exist"); 
        return false; 
    } 

    printSolution(path); 
    return true; 
} 

/* A utility function to print solution 
   æ‰“å°æ­¤å›è·¯
*/

void printSolution(int path[]) 
{ 
    printf ("Solution Exists:"
            " Following is one Hamiltonian Cycle \n"); 
    for (int i = 0; i < V; i++) 
        printf(" %d ", path[i]); 

    // Let us print the first vertex again to show the complete cycle 
    printf(" %d ", path[0]); 
    printf("\n"); 
} 

// driver program to test above function 
int main() 
{ 
   /* Let us create the following graph 
      (0)--(1)--(2) 
       |   / \   | 
       |  /   \  | 
       | /     \ | 
      (3)-------(4)    */
   bool graph1[V][V] = {{0, 1, 0, 1, 0}, 
                      {1, 0, 1, 1, 1}, 
                      {0, 1, 0, 0, 1}, 
                      {1, 1, 0, 0, 1}, 
                      {0, 1, 1, 1, 0}, 
                     }; 

    // Print the solution 
    hamCycle(graph1); 

   /* Let us create the following graph 
      (0)--(1)--(2) 
       |   / \   | 
       |  /   \  | 
       | /     \ | 
      (3)       (4)    */
    bool graph2[V][V] = {{0, 1, 0, 1, 0}, 
                      {1, 0, 1, 1, 1}, 
                      {0, 1, 0, 0, 1}, 
                      {1, 1, 0, 0, 0}, 
                      {0, 1, 1, 0, 0}, 
                     }; 

    // Print the solution 
    hamCycle(graph2); 

    return 0; 
}
```

# å°ç»“è®º

1. å¼€é˜Ÿåˆ—è¿›è¡Œæ‹“æ‰‘æ’åºå¯ä»¥å»é™¤æœ‰å‘å›¾ä¸­çš„ç¯å¤–èŠ‚ç‚¹
2. éœå°”å®šç†ï¼šäºŒåˆ†å›¾Gä¸­çš„ä¸¤éƒ¨åˆ†é¡¶ç‚¹é›†åˆåˆ†åˆ«ä¸ºX, Y,å‡è®¾æœ‰ |X|<=|Y|ã€‚Gå›¾å­˜åœ¨å®Œç¾åŒ¹é…çš„å……åˆ†å¿…è¦æ¡ä»¶æ˜¯ï¼šXä¸­çš„ä»»æ„kä¸ªç‚¹è‡³å°‘ä¸Yä¸­çš„kä¸ªç‚¹ç›¸é‚»ï¼Œå³å¯¹äºXä¸­çš„ä¸€ä¸ªç‚¹é›†W ï¼Œä»¤N(W)ä¸ºWæ‰€è¿çš„ç‚¹ï¼Œ éœå°”å®šç†å³å¯¹äºä»»æ„Wæœ‰ |W|<=|N(W)|

éœå°”å®šç†æ¨è®ºï¼šäºŒåˆ†å›¾çš„æœ€å¤§åŒ¹é…ä¸ºï¼š|X|âˆ’max{|W|âˆ’|N(W)|}ï¼Œå…¶ä¸­Wä¸ºXçš„ä»»æ„å­é›†ã€‚ï¼ˆä¸ä¸€å®šæ˜¯å®Œç¾åŒ¹é…ï¼Œå¹¶ä¸”è¦æŠŠä¸ç¬¦åˆé¢˜æ„çš„æƒ…å†µæ’é™¤ï¼‰

